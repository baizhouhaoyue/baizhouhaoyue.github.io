<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="BAI ZHOU">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2024/01/07/linux高级系统编程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="知识点【1】系统调用概述 1.1系统调用概述 系统调用：是操作系统提供给用户可操作内核资源的函数接口。  例如：用户可以通过文件系统相关的系统调用，请求系统打开文件、关闭文件或读写文件。  系统调用按照功能逻辑大致可分为： 进程控制、进程间通信、文件系统控制、系统控制、内存管理、网络管理、 socket 控制、用户管理。 系统调用的返回值： 通常，用一个负的返回值来表明错误，返回一个 0 值表明成">
<meta property="og:type" content="article">
<meta property="og:title" content="linux高级系统编程">
<meta property="og:url" content="http://example.com/2024/01/07/linux%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="白昼">
<meta property="og:description" content="知识点【1】系统调用概述 1.1系统调用概述 系统调用：是操作系统提供给用户可操作内核资源的函数接口。  例如：用户可以通过文件系统相关的系统调用，请求系统打开文件、关闭文件或读写文件。  系统调用按照功能逻辑大致可分为： 进程控制、进程间通信、文件系统控制、系统控制、内存管理、网络管理、 socket 控制、用户管理。 系统调用的返回值： 通常，用一个负的返回值来表明错误，返回一个 0 值表明成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imgs/linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20240107212750979.png">
<meta property="og:image" content="http://example.com/imgs/linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20240107212814517.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170428506.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170519294.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170532936.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170553549.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170615729.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170626113.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170738456.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170809592.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170825291.png">
<meta property="og:image" content="https://note.youdao.com/yws/res/1286/WEBRESOURCEa2e40c0047c31572abfb3aceed1e0ceb">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107171654904.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107171936497.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107171949389.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172006622.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172023678.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172038085.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172052907.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172122112.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172317814.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172538078.png">
<meta property="og:image" content="https://note.youdao.com/yws/res/1332/WEBRESOURCEee37c888853b601663e20fa3af09fd3f">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173415612.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173425599.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173541630.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173602680.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173839784.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173934286.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173953102.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174037036.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174123799.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174214147.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174202652.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174523608.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174652832.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174747156.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174928656.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181013467.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181146933.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181305991.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181453510.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181909314.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107182953387.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107183232779.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107184929545.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185119746.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185130149.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185659786.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185713739.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190049758.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190106177.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190129138.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190629356.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107191043092.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107191153439.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107191236763.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107192342731.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107204726058.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107204741651.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107205719871.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107205939722.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107210054413.png">
<meta property="og:image" content="http://example.com/imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107210110473.png">
<meta property="article:published_time" content="2024-01-07T08:56:21.000Z">
<meta property="article:modified_time" content="2024-01-07T13:32:31.585Z">
<meta property="article:author" content="白昼">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20240107212750979.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            linux高级系统编程 -
        
        白昼的宝典
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
        <link href="" rel="stylesheet">
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":true,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"BAI ZHOU","subtitle":{"text":["每朵云都下落不明","每盏月亮都不知所踪"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":"https://github.com/baizhouhaoyue/baizhouhaoyue.github.io","instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.7.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Status":{"path":"https://status.evanluo.top/","icon":"fa-regular fa-chart-bar"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/baizhouhaoyue/baizhouhaoyue.github.io","Blog":"https://ohevan.com","Friends":"/friends"}},"Links":{"icon":"fa-regular fa-link","submenus":{"Hexo":"https://hexo.io/zh-cn/","Themes":"https://hexo.io/themes/","Redefine":"https://redefine-docs.ohevan.com/getting-started"}}},"search":{"enable":true,"preload":true},"tags":{"Tags":{"icon":"fa-solid fa-tags","path":"/tags/"}},"categories":{"Categories":{"icon":"fa-solid fa-folder","path":"/categories/"}}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"现在正在完善qt相关知识点","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/8/15 00:00:00"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>



<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                白昼的宝典
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   target="_blank" rel="noopener" href="https://status.evanluo.top/"
                                        >
                                    <i class="fa-regular fa-chart-bar fa-fw"></i>
                                    状态
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    关于
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a href="/about">
                                                    ME
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://github.com/baizhouhaoyue/baizhouhaoyue.github.io">
                                                    GITHUB
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://ohevan.com">
                                                    BLOG
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a href="/friends">
                                                    友情链接
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-link fa-fw"></i>
                                    链接
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">
                                                    HEXO
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://hexo.io/themes/">
                                                    THEMES
                                                </a>
                                            </li>
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://redefine-docs.ohevan.com/getting-started">
                                                    REDEFINE
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           target="_blank" rel="noopener" href="https://status.evanluo.top/"
                        >
                            <span>
                                状态
                            </span>
                            
                                <i class="fa-regular fa-chart-bar fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-About"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/about">ME</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://github.com/baizhouhaoyue/baizhouhaoyue.github.io">GITHUB</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://ohevan.com">BLOG</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           href="/friends">友情链接</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-Links"
                        >
                            <span>
                                链接
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">HEXO</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://hexo.io/themes/">THEMES</a>
                                    </div>
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://redefine-docs.ohevan.com/getting-started">REDEFINE</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">35</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux高级系统编程</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.wXOy_YCJC8bSlnbu_R1mugHaFQ?pid=ImgDet&rs=1">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">BAI ZHOU</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-01-07 16:56:21</span>
        <span class="mobile">2024-01-07 16:56:21</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-01-07 21:32:31</span>
            <span class="mobile">2024-01-07 21:32:31</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/linux/">linux</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux/">linux</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p><strong>知识点【1】系统调用概述</strong></p>
<p><strong>1.1系统调用概述</strong></p>
<p>系统调用：是操作系统提供给用户可操作内核资源的函数接口。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20240107212750979.png"
                      alt="image-20240107212750979"
                ></p>
<p>例如：用户可以通过文件系统相关的系统调用，请求系统打开文件、关闭文件或读写文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20240107212814517.png"
                      alt="image-20240107212814517"
                ></p>
<p><strong>系统调用按照功能逻辑大致可分为：</strong></p>
<p>进程控制、进程间通信、文件系统控制、系统控制、内存管理、网络管理、 socket 控制、用户管理。</p>
<p><strong>系统调用的返回值：</strong></p>
<p>通常，用一个负的返回值来表明错误，返回一个 0 值表明成功。错误信息存放在全局变量 errno 中，用户可用 perror 函数打印出错信息。</p>
<p><strong>系统调用遵循的规范：</strong></p>
<p>在 Linux 中，应用程序编程接口(API)遵循 POSIX 标准。</p>
<p><strong>1.2系统调用和库函数的区别</strong></p>
<p>系统调用与库函数之间存在包含关系。</p>
<p>库函数由第三方提供的函数，可以调用系统调用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170428506.png"
                      alt="image-20240107170428506"
                ></p>
<p>系统调用是需要时间的， 程序中频繁的使用系统调用会降低程序的运行效率。</p>
<p>C 库中 IO 函数工作流程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170519294.png"
                      alt="image-20240107170519294"
                ></p>
<p><strong>1.3文件描述符（用于区分文件或设备等，便于管理）</strong></p>
<p><strong>文件描述符</strong>：非负整数，代表已打开文件，文件描述符相当于这个已打开文件的标号。</p>
<p>获取到文件描述符之后我们就可以对该文件进行I&#x2F;O操作。</p>
<p>每个进程都会有一张文件描述符表（存放在内核态），记录的是当前进程打开的所有文件描述符。</p>
<p>标准输入、 标准输出、 标准错误输出设备文件被打开， 对应的文件描述符 0、 1、 2 记录在表中。</p>
<p>程序运行起来后这三个文件描述符是默认打开的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170532936.png"
                      alt="image-20240107170532936"
                ></p>
<p>程序运行起来后打开其他文件时， 系统会返回文件描述符表中最小可用的文件描述符， 并将此文件描述符记录在表中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170553549.png"
                      alt="image-20240107170553549"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170615729.png"
                      alt="image-20240107170615729"
                ></p>
<p><strong>查看及修改文件描述符数量的命令</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170626113.png"
                      alt="image-20240107170626113"
                ></p>
<p><strong>知识点【2】文件打开读写关闭</strong></p>
<p><strong>2.1 打开文件（得到文件描述符的过程）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></div>

<p>功能：</p>
<p>打开文件， 如果文件不存在则可以选择创建。</p>
<p>参数：</p>
<p>pathname： 文件的路径及文件名</p>
<p>flags： 打开文件的行为标志， 必选项 O_RDONLY, O_WRONLY, O_RDWR，O_CREAT</p>
<p>mode： 这个参数， 只有在文件不存在时有效， 指新建文件时指定文件的权限</p>
<p>返回值：</p>
<p>成功： 成功返回打开的文件描述符</p>
<p>失败： -1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170738456.png"
                      alt="image-20240107170738456"
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> int main() </span></span><br><span class="line">&#123;    <span class="type">int</span> fd = open(<span class="string">&quot;tmp&quot;</span>, O_CREAT, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;        </span><br><span class="line">perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);     </span><br><span class="line">close(fd);     </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170809592.png"
                      alt="image-20240107170809592"
                ></p>
<p>作业2：创建一个文件，拥有者具备写执行权限，所属组拥有读执行权限，其他用户拥有执行权限</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)    </span><br><span class="line">&#123;        </span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./tmp&quot;</span>, O_RDONLY);        </span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)        </span><br><span class="line">&#123;            </span><br><span class="line">perror(<span class="string">&quot;open&quot;</span>);            </span><br><span class="line"><span class="keyword">break</span>;        </span><br><span class="line">&#125;        </span><br><span class="line">cnt++;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cnt = %d\n&quot;</span>, cnt); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107170825291.png"
                      alt="image-20240107170825291"
                ></p>
<p><strong>2.2关闭文件（取消对文件描述符的拥有权）</strong></p>
<p>#include &lt;unistd.h&gt; </p>
<p>int close(int fd)</p>
<p>功能：</p>
<p>关闭已打开的文件</p>
<p>参数：</p>
<p>fd : 文件描述符， open()的返回值</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： -1, 并设置 errno</p>
<p><strong>2.3 从文件读数据 read</strong></p>
<p>#include &lt;unistd.h&gt; </p>
<p>ssize_t read(int fd, void *buf, size_t count);</p>
<p>功能：</p>
<p>把指定数目的数据读到内存（缓冲区）</p>
<p>参数：</p>
<p>fd : 文件描述符</p>
<p>buf : 内存首地址</p>
<p>count : 读取的字节个数</p>
<p>返回值：</p>
<p>成功： 实际读取到的字节个数</p>
<p>失败： - 1</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line"><span class="type">int</span> fd = <span class="number">-1</span>;    </span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;    </span><br><span class="line"><span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;     </span><br><span class="line">fd = open(<span class="string">&quot;./Color.txt&quot;</span>, O_RDONLY);    </span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)    </span><br><span class="line">&#123;        </span><br><span class="line">perror(<span class="string">&quot;open&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)    </span><br><span class="line">&#123;        </span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));        </span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));       </span><br><span class="line">buf[ret] = <span class="string">&#x27;\0&#x27;</span>;       </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%ld]:%s\n&quot;</span>, ret, buf);        </span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="keyword">sizeof</span>(buf))        </span><br><span class="line">&#123;            </span><br><span class="line"><span class="keyword">break</span>;        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;     </span><br><span class="line">close(fd); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.4 write函数</strong></p>
<p>把指定数目的数据写到文件。</p>
<p>#include &lt;unistd.h&gt; </p>
<p>ssize_t write(int fd, const void *addr,size_t count);</p>
<p>参数：</p>
<p>fd：文件描述符。</p>
<p>addr：数据首地址。</p>
<p>count：写入数据的字节个数。</p>
<p>返回值：</p>
<p>成功返回实际写入数据的字节个数。</p>
<p>失败返回-1，可以利用 perror 去查看原因。</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line"><span class="type">int</span> fd = <span class="number">0</span>;    </span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;    </span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello 1000phone&quot;</span>;     </span><br><span class="line">fd = open(<span class="string">&quot;./tmp&quot;</span>, O_WRONLY);    </span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)    </span><br><span class="line">&#123;        </span><br><span class="line">perror(<span class="string">&quot;open&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">ret = write(fd, str, <span class="built_in">strlen</span>(str));    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;write to tmp %d Bytes\n&quot;</span>, ret);        </span><br><span class="line">close(fd);    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>案例：实现文件copy操作</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;    </span><br><span class="line"><span class="type">int</span> src_fd = <span class="number">-1</span>, dst_fd = <span class="number">-1</span>;    </span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;    </span><br><span class="line"><span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;     </span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>)    </span><br><span class="line">&#123;        </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please input three varible!&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">&#125;     </span><br><span class="line">src_fd = open(argv[<span class="number">1</span>], O_RDONLY);    </span><br><span class="line">dst_fd = open(argv[<span class="number">2</span>], O_CREAT | O_WRONLY, <span class="number">0666</span>);     </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)    </span><br><span class="line">&#123;       </span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));      </span><br><span class="line">ret = read(src_fd, buf, <span class="keyword">sizeof</span>(buf));    </span><br><span class="line">write(dst_fd, buf, ret);  </span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="keyword">sizeof</span>(buf))   </span><br><span class="line">&#123;          </span><br><span class="line"><span class="keyword">break</span>;     </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.5 remove函数（删除文件或目录）</strong></p>
<p>#include &lt;stdio.h&gt; </p>
<p>int remove(const char *pathname);</p>
<p>参数：</p>
<p>pathname ：文件的路名+文件名。</p>
<p>返回值：</p>
<p>成功返回 0。</p>
<p>失败返回-1，可以利用 perror 去查看原因。</p>
<p><strong>知识点【3】文件的阻塞特性</strong></p>
<p><strong>3.1read函数的阻塞概述</strong></p>
<p>1.read函数默认为阻塞型函数，如果读不到数据，将阻塞当前进程不继续执行，直到有数据可读，才继续执行。</p>
<p>2.非阻塞的特性：如果没数据，立即返回，继续执行。</p>
<p><strong>3.2 打开文件设置非阻塞（open函数内加入非阻塞选项）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/*测试是将O_NONBLOCK去掉看下效果*/</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="type">int</span> fd = <span class="number">-1</span>;   </span><br><span class="line"><span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY | O_NONBLOCK); <span class="comment">///&lt; /dev/tty 代表我们当前终端   </span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)                              </span><br><span class="line"><span class="comment">///&lt; O_NONBLOCK以非阻塞方式打开  </span></span><br><span class="line">&#123;                             </span><br><span class="line"><span class="comment">///&lt; 文件或设备       </span></span><br><span class="line">perror(<span class="string">&quot;open&quot;</span>);       </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;befor read!\n&quot;</span>);  </span><br><span class="line">read(fd, buf, <span class="keyword">sizeof</span>(buf));  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after read!\n&quot;</span>);  </span><br><span class="line">close(fd);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.3 fcntl函数设置文件描述符的阻塞特性</strong></p>
<p>#include &lt;unistd.h&gt; </p>
<p>#include &lt;fcntl.h&gt;</p>
<p> int fcntl(int fd, int cmd, … &#x2F;* arg *&#x2F;);</p>
<p>**1.**功能： 改变已打开的文件性质， fcntl 针对描述符提供控制。</p>
<p>参数：</p>
<p>fd： 操作的文件描述符</p>
<p>cmd： 操作方式</p>
<p>arg： 针对 cmd 的值， fcntl 能够接受第三个参数 int arg。</p>
<p>返回值：</p>
<p>成功： 返回某个其他值</p>
<p>失败： -1</p>
<p><strong>2</strong>.fcntl设置阻塞特性的三个步骤：</p>
<ul>
<li>获取文件的状态标记</li>
<li>将获得的标记设置为非阻塞</li>
<li>将修改后的文件阻塞状态标记设置到当前文件描述符中</li>
</ul>
<p>案例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;  </span><br><span class="line">char buf[32] = &#123;&#125;; </span><br><span class="line">int flag = 0;  </span><br><span class="line">printf(&quot;before read!\n&quot;);   </span><br><span class="line">flag = fcntl(0, F_GETFL);  </span><br><span class="line">flag |= O_NONBLOCK;  </span><br><span class="line">fcntl(0, F_SETFL, flag);  </span><br><span class="line">read(0, buf, sizeof(buf));  ///&lt;从标准输入端读取字符串     printf(&quot;after read!\n&quot;);  </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【4】文件状态</strong></p>
<p><strong>1.文件状态函数</strong></p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;stat.h&gt; </p>
<p>#include &lt;unistd.h&gt; </p>
<p>int stat(const char *path, struct stat *buf);  &#x2F;&#x2F;获取普通文件状态 int lstat(const char *pathname, struct stat *buf);  &#x2F;&#x2F;获取链接文件状态</p>
<p>功能：</p>
<p>获取文件状态信息</p>
<p>stat 和 lstat 的区别：</p>
<p>当文件是一个符号链接时， lstat 返回的是该符号链接本身的信息；</p>
<p>而 stat 返回的是该链接指向的文件的信息。</p>
<p>参数：</p>
<p>path： 文件名</p>
<p>buf： 保存文件信息的结构体</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败: -1</p>
<p>文件信息的结构体 struct stat</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span>      </span><br><span class="line"><span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span>      </span><br><span class="line"><span class="type">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span>     </span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* protection */</span><span class="comment">//文件的类型和存取的权限     </span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span>    </span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span>    </span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span>     </span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span>    </span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span>     </span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span>    </span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span>       </span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond         precision for the following timestamp fields.          For the details before Linux 2.6, see NOTES. */</span>      </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span>    </span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span>      </span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec </span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>​    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://note.youdao.com/yws/res/1286/WEBRESOURCEa2e40c0047c31572abfb3aceed1e0ceb"
                      alt="0"
                ></p>
<p>案例：获取文件类型及大小</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> ret = <span class="number">-1</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span>  </span><br><span class="line">ret = stat(<span class="string">&quot;.&quot;</span>, &amp;st);  </span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">&#123;     </span><br><span class="line">perror(<span class="string">&quot;stat&quot;</span>);     </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;    <span class="comment">// 判断文件类型  </span></span><br><span class="line"><span class="keyword">if</span> (S_ISREG(st.st_mode))    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;is normal file!\n&quot;</span>); </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(st.st_mode))   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;is directory!\n&quot;</span>);    <span class="comment">// 获取文件大小 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the size is : %d\n&quot;</span>, st.st_size);     <span class="comment">// 获取文件的权限  </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.文件目录操作</strong></p>
<p><strong>2.1 目录操作相关函数</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107171654904.png"
                      alt="image-20240107171654904"
                ></p>
<p>案例：查看指定目录下的文件和目录</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DEFAULT_SOURCE </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    DIR *dir = opendir(<span class="string">&quot;/home/yananfu2000&quot;</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;      </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent</span> =</span> readdir(dir);      </span><br><span class="line">        <span class="keyword">if</span>(dirent == <span class="literal">NULL</span>) <span class="keyword">break</span>;     </span><br><span class="line">        <span class="keyword">if</span>(dirent-&gt;d_type == DT_REG)    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;普通文件：%s\n&quot;</span>, dirent-&gt;d_name);    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dirent-&gt;d_type == DT_DIR)     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;目录文件：%s\n&quot;</span>, dirent-&gt;d_name);   </span><br><span class="line">    &#125;     closedir(dir);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如未识别DT_REG、DT_DIR等需在源文件的首部加上 #define _DEFAULT_SOURCE</p>
<p>案例：遍历多级目录</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DEFAULT_SOURCE </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_search_dir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirname)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    DIR *dir = opendir(dirname);  </span><br><span class="line">    <span class="type">char</span> file_dir[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="type">char</span> pre_name[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> dir_flag = <span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">memset</span>(file_dir, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(file_dir));  </span><br><span class="line">    <span class="built_in">strcpy</span>(file_dir, dirname);   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent</span> =</span> readdir(dir);   </span><br><span class="line">        <span class="keyword">if</span> (dirent == <span class="literal">NULL</span>)     </span><br><span class="line">            <span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">if</span> (dirent-&gt;d_type == DT_DIR &amp;&amp; <span class="built_in">strcmp</span>(dirent-&gt;d_name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(dirent-&gt;d_name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)        </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="keyword">if</span> (!dir_flag)       </span><br><span class="line">            &#123;          </span><br><span class="line">                <span class="built_in">strcat</span>(file_dir, <span class="string">&quot;/&quot;</span>);      </span><br><span class="line">                <span class="built_in">strcat</span>(file_dir, dirent-&gt;d_name);  </span><br><span class="line">            &#125;     </span><br><span class="line">            <span class="keyword">else</span>     </span><br><span class="line">            &#123;         </span><br><span class="line">                <span class="built_in">strcat</span>(file_dir, <span class="string">&quot;/../&quot;</span>);       </span><br><span class="line">                <span class="built_in">strcat</span>(file_dir, dirent-&gt;d_name);      </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pre_name, dirent-&gt;d_name) != <span class="number">0</span>)      </span><br><span class="line">                &#123;            </span><br><span class="line">                    <span class="built_in">strcat</span>(file_dir, <span class="string">&quot;/../&quot;</span>);    </span><br><span class="line">                    <span class="built_in">strcat</span>(file_dir, dirent-&gt;d_name);  </span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;          </span><br><span class="line">            dir_flag = <span class="number">1</span>;   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s 目录文件\n&quot;</span>, file_dir); </span><br><span class="line">            my_search_dir(file_dir);  </span><br><span class="line">            <span class="built_in">memset</span>(pre_name, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(pre_name));</span><br><span class="line">            <span class="built_in">strcpy</span>(pre_name, dirent-&gt;d_name);    </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dirent-&gt;d_type == DT_REG)  </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s/%s 普通文件\n&quot;</span>, file_dir, dirent-&gt;d_name);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    closedir(dir); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    my_search_dir(<span class="string">&quot;/home/yananfu2000/work/edu/class_2301&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【4】进程</strong></p>
<p><strong>4.1进程和程序的区别</strong></p>
<p>进程就是正在运行的程序。</p>
<p>程序：占用磁盘空间 静态。</p>
<p>进程：占用内存空间   动态的(创建、消亡、调度)</p>
<p><strong>4.2 单道和多道程序</strong></p>
<p>单道程序设计：所有进程一个一个排队执行。 若 A 阻塞， B 只能等待， 即使 CPU 处于空闲状态。</p>
<p>多道程序设计：在计算机内存中同时存放几道相互独立的程序， 它们在管理程序控制之下， 相互穿插的运行。（并发与并行）</p>
<p><strong>4.3并行与并发</strong></p>
<p>并行：多核 指在同一时刻，有多个指令在不同的处理器上同时执行。</p>
<p>   <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107171936497.png"
                      alt="image-20240107171936497"
                ></p>
<p>并发：（单核，宏观上是并行）多条指令快速轮转执行，达到宏观上的并行效果，微观上是顺序执行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107171949389.png"
                      alt="image-20240107171949389"
                ></p>
<p><strong>4.4进程控制块(PCB)</strong></p>
<p>进程运行时， 内核为进程每个进程分配一个 PCB（进程控制块） ， 维护进程相关的信息， Linux 内核的进程控制块是 task_struct 结构体.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172006622.png"
                      alt="image-20240107172006622"
                ></p>
<p>其内部成员有很多， 我们掌握以下部分即可： 进程 id。 系统中每个进程有唯一的id， 在 C 语言中用 pid_t 类型表示， 其实就是一个非负整数。 进程的状态， 有就绪、 运行、 挂起、 停止等状态。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172023678.png"
                      alt="image-20240107172023678"
                ></p>
<p><strong>知识点【5】进程的状态</strong></p>
<p><strong>5.1 进程的3大状态</strong></p>
<p>等待态、就绪态、执行态</p>
<p>等待态：缺少执行条件（执行条件不满足）。</p>
<p>就绪态：执行条件具备，等待CPU的调度。</p>
<p>执行态：正在被CPU调度。</p>
<p>三态模型：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172038085.png"
                      alt="image-20240107172038085"
                ></p>
<p>五态模型：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172052907.png"
                      alt="image-20240107172052907"
                ></p>
<p><strong>5.2 查看进程状态</strong></p>
<p>命令：ps -aux</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172122112.png"
                      alt="image-20240107172122112"
                ></p>
<p>前台进程：可通过终端交互的进程     后台进程：不可通过终端交互的进程</p>
<p>特殊的进程号：</p>
<p>0号进程（隐藏）：进程调度程序（由内核创建）</p>
<p>1号进程：系统初始化进程（由内核创建）</p>
<p><strong>知识点【6】进程号</strong></p>
<p><strong>6.1 进程号概述</strong></p>
<p>每个进程都由一个进程号来标识（可以找到对应的task_struct）,其类型为 pid_t（整型） ， 进程号的范围： 0～32767。 进程号总是唯一的， 但进程号可以重用。 当一个进程终止后， 其进程号就可以再次使用。</p>
<p>可以通过命令查看自身系统支持的最大进程号：ulimit -a——–&gt;max user processes</p>
<p>PID：当前进程的进程号</p>
<p>PPID：当前进程父进程的进程号</p>
<p>PGID：当前进程所属组的进程组号</p>
<p><strong>6.2 获取进程ID（父进程、组进程）</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172317814.png"
                      alt="image-20240107172317814"
                ></p>
<p>案例：获取进程ID、父进程ID、所属组ID</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程ID号： %d \n&quot;</span>, getpid());   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程的父进程ID: %d\n&quot;</span>, getppid()); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程组ID号：%d \n&quot;</span>, getpgid(getpid())); </span><br><span class="line">    getchar(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【7】fork创建进程</strong></p>
<p><strong>7.1 父子进程的概述</strong></p>
<p>系统允许一个进程创建新进程， 新进程即为子进程。</p>
<p><strong>7.2 fork创建进程</strong></p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;unistd.h&gt; </p>
<p>pid_t fork(void);</p>
<p>功能：</p>
<p>​    用于从一个已存在的进程中创建一个新进程， 新进程称为子进程， 原进程称为父进程。</p>
<p>参数：</p>
<p>​    无</p>
<p>返回值：</p>
<p>​    成功： 子进程中返回 0， 父进程中返回子进程 ID。 pid_t， 为整型。</p>
<p>​    失败： 返回-1。</p>
<p>失败的两个主要原因是：</p>
<p>1） 当前的进程数已经达到了系统规定的上限， 这时 errno 的值被设置为 -EAGAIN。</p>
<p>2） 系统内存不足， 这时 errno 的值被设置为 -ENOMEM。</p>
<p>案例：fork的使用</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">child_main</span><span class="params">(<span class="type">int</span> num)</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是子进程: %d; num = %d\n&quot;</span>, getpid(), num); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)   </span><br><span class="line">    &#123;    </span><br><span class="line">        child_main(num); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        num = <span class="number">1000</span>;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这是父进程：%d; num = %d \n&quot;</span>, getpid(), num);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>7.3 fork的父子进程关系</strong></p>
<p>fork 函数得到的子进程是父进程的一个复制品， 它从父进程处继承了整个进程的地址空间。 地址空间: 包括进程上下文、 进程堆栈、 打开的文件描述符、 信号控制设定、 进程优先级、 进程组号等。 子进程所独有的只有它的进程号， 计时器等。 因此， 使用 fork 函数的代价是很大的。</p>
<p>   <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107172538078.png"
                      alt="image-20240107172538078"
                ></p>
<p>fork创建的子进程，子进程与父进程有独立的空间，子进程复制了父进程的空间内容。</p>
<p>作业：验证子进程操作父进程文件描述符。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// printf是库函数，“1.hello fork”写到缓冲区 也会被子进程复制一份   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1.hello fork&quot;</span>);    </span><br><span class="line">    <span class="comment">// write是系统调用，写入1号文件， 没有缓冲区 不能被子进程复制    </span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;2. hello fork&quot;</span>, <span class="number">15</span>);   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)   </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">///&lt; 子进程  </span></span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">///&lt; 父进程  </span></span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>   <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://note.youdao.com/yws/res/1332/WEBRESOURCEee37c888853b601663e20fa3af09fd3f"
                      alt="0"
                ></p>
<p><strong>知识点【8】回收子进程资源</strong></p>
<p>在每个进程退出的时候， 内核释放该进程所有的资源、 包括打开的文件、 占用的内存等。 但是仍然为其保留一定的信息， 这些信息主要主要指进程控制块 PCB 的信息（包括进程号、 退出状态、 运行时间等） 。</p>
<p>父进程回收子进程资源（PCB）。</p>
<p>注意： 一次 wait 或 waitpid 调用只能清理一个子进程， 清理多个子进程应使用循环。</p>
<p><strong>8.1wait函数回收子进程资源</strong></p>
<p>函数说明: #include &lt;sys&#x2F;types.h&gt;</p>
<p> #include &lt;sys&#x2F;wait.h&gt; </p>
<p>pid_t wait(int *status);</p>
<p>功能：</p>
<p>  等待任意一个子进程结束， 如果任意一个子进程结束了， 此函数会回收该子进程的资源。</p>
<p>参数：</p>
<p>  status : 进程退出时的状态信息。</p>
<p>返回值：</p>
<p>  成功： 已经结束子进程的进程号</p>
<p>  失败： -1</p>
<p>注：wait的状态值（status）</p>
<p>如果参数status的值不是NULL，wait()就会把子进程退出时的状态取出并存入其中，是整型值（int), 指出子进程是正常退出还是非正常退出，这个退出信息在一个int值中包含多规格字节，直接使用这个值没有意义的，我们需要一个宏定义取出其中的每个字段。</p>
<p>取出子进程退出信息WIFEXITED(status)，如果子进程正常退出，取出的字段是非零值。</p>
<p>返回子进程的退出状态WEXITSTATUS(status)，退出状态保存在status的8–16位。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// create child process </span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;     </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">        <span class="comment">// child process </span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)   </span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d剩余的生命%d\n&quot;</span>, getpid(), i);   </span><br><span class="line">            usleep(<span class="number">1000</span> * <span class="number">1000</span>);    </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// exit(-1); // 库函数 用于进程以何种状态退出，底层使用系统调用_exit()  </span></span><br><span class="line">        _exit(<span class="number">10</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程%d等待子进程%d的结束！\n&quot;</span>, getpid(), pid);  </span><br><span class="line">        <span class="comment">// wait阻塞型函数   </span></span><br><span class="line">        <span class="type">pid_t</span> ret = wait(&amp;status); <span class="comment">// 假如父进程不想关心子进程的退出状态， 直接填NULL  </span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))   </span><br><span class="line">            <span class="comment">// 子进程正常退出     </span></span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="comment">// 取出状态值     </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d已结束，状态值为：%d!\n&quot;</span>, ret, WEXITSTATUS(status));  </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程结束！\n&quot;</span>);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>8.2waitpid()回收子进程资源</strong></p>
<p><strong>函数说明：</strong></p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;wait.h&gt;</p>
<p> pid_t waitpid(pid_t pid, int *status, int options);</p>
<p>功能:</p>
<p>等待子进程终止， 如果子进程终止了， 此函数会回收子进程的资源。</p>
<p>参数：</p>
<p>pid : 参数 pid 的值有以下几种类型：</p>
<p>pid &gt; 0 等待进程 ID 等于 pid 的子进程。</p>
<p>pid &#x3D; 0 等待同一个进程组中的任何子进程， 如果子进程已经加入了别的进程</p>
<p>组， waitpid 不会等待它。</p>
<p>pid &#x3D; -1 等待任一子进程， 此时 waitpid 和 wait 作用一样。</p>
<p>pid &lt; -1 等待指定进程组中的任何子进程， 这个进程组的 ID 等于 pid 的绝对</p>
<p>值。</p>
<p>status : 进程退出时的状态信息。 和 wait() 用法一样。</p>
<p>options : options 提供了一些额外的选项来控制 waitpid()。</p>
<p>0： 同 wait()， 阻塞父进程， 等待子进程退出。</p>
<p>WNOHANG： 没有任何已经结束的子进程， 则立即返回(非阻塞)。</p>
<p>WUNTRACED： 如果子进程暂停了则此函数马上返回， 并且不予以理会子进程的结束状态。 （由于涉及到一些跟踪调试方面的知识， 加之极少用到）</p>
<p>返回值：</p>
<p>waitpid() 的返回值比 wait() 稍微复杂一些， 一共有 3 种情况：</p>
<ol>
<li><p>当正常返回的时候， waitpid() 返回收集到的已经回收子进程的进程号；</p>
</li>
<li><p>如果设置了选项 WNOHANG， 而调用中 waitpid() 发现没有子进程退出返回 0，父进程的所有子进程都退出返回-1，返回&gt;0</p>
</li>
</ol>
<p>  表示等到了一个子进程退出（重要)；</p>
<ol start="3">
<li>如果调用中出错， 则返回-1， 这时 errno 会被设置成相应的值以指示错误所在， 如： 当 pid 所对应的子进程不存在， 或此进程存在， 但不是调用进程的子进程， waitpid() 就会出错返回， 这时 errno 被设置为 ECHILD；</li>
</ol>
<p>案例：waitpid()和wait()等价</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// create child process   </span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child process   </span></span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)     </span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d剩余的生命%d\n&quot;</span>, getpid(), i); </span><br><span class="line">            usleep(<span class="number">1000</span> * <span class="number">1000</span>);     </span><br><span class="line">        &#125;         <span class="comment">// exit(-1); // 库函数 用于进程以何种状态退出，底层使用系统调用_exit()  </span></span><br><span class="line">        _exit(<span class="number">10</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程%d等待子进程%d的结束！\n&quot;</span>, getpid(), pid);         <span class="comment">// waitpid实现与wait等价     </span></span><br><span class="line">        <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>, status); </span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) <span class="comment">// 子进程正常退出   </span></span><br><span class="line">        &#123;          </span><br><span class="line">            <span class="comment">// 取出状态值          </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d已结束，状态值为：%d!\n&quot;</span>, ret, WEXITSTATUS(status));  </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程结束！\n&quot;</span>); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>8.2特殊进程</strong></p>
<p><strong>8.2.1 僵尸进程</strong></p>
<p>子进程退出，父进程没有回收进程资源，子进程为僵尸进程(有危害)，子进程的PID被占用，也会浪费系统资源。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="string">&#x27;&#x27;#include &lt;stdlib.h&gt; </span></span><br><span class="line"><span class="string">    int main(int argc, char const *argv[]) </span></span><br><span class="line"><span class="string">&#123;   </span></span><br><span class="line"><span class="string">    pid_t pid = fork();  </span></span><br><span class="line"><span class="string">    if (pid == 0) ///&lt; 子进程  </span></span><br><span class="line"><span class="string">    &#123;     </span></span><br><span class="line"><span class="string">        printf(&quot;子进程PID = %d\n&quot;, getpid());      </span></span><br><span class="line"><span class="string">        _exit(-1); </span></span><br><span class="line"><span class="string">    &#125;   </span></span><br><span class="line"><span class="string">    else if (pid &gt; 0) ///&lt; 父进程   </span></span><br><span class="line"><span class="string">    &#123;       </span></span><br><span class="line"><span class="string">        while (1)       </span></span><br><span class="line"><span class="string">            ;   </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">    return 0; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>8.2.2 孤儿进程</strong></p>
<p>父进程先退出，子进程成为孤儿进程（无害的）。</p>
<p>孤儿进程被1号进程接管（当孤儿进程结束时，1号进程负责回收其资源）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">///&lt; 子进程 </span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程PID = %d\n&quot;</span>, getpid());   </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)      </span><br><span class="line">            ;       </span><br><span class="line">        _exit(<span class="number">-1</span>); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">///&lt; 父进程 </span></span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>8.2.3守护进程</strong></p>
<p>脱离终端的孤儿进程，守护进程是个特殊的孤儿进程。</p>
<p><strong>知识点9：fork创建多个子进程</strong></p>
<p><strong>9.1创建多进程（不可取的方法）</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">    &#123;       </span><br><span class="line">        fork();   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173415612.png"
                      alt="image-20240107173415612"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173425599.png"
                      alt="image-20240107173425599"
                ></p>
<p><strong>9.2创建多进程（正确方法）</strong></p>
<p>不让子进程再创建子进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="type">pid_t</span> pid = fork();     </span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)       </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173541630.png"
                      alt="image-20240107173541630"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173602680.png"
                      alt="image-20240107173602680"
                ></p>
<p>案例3：多进程开发的完整案例</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      </span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)       </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">///&lt; 子进程1  </span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程1：%u\n&quot;</span>, getpid());    </span><br><span class="line">        sleep(<span class="number">10</span>);       </span><br><span class="line">        _exit(<span class="number">0</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">///&lt; 子进程2    </span></span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程2：%u\n&quot;</span>, getpid());   </span><br><span class="line">        sleep(<span class="number">6</span>);    </span><br><span class="line">        _exit(<span class="number">0</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="comment">///&lt; 子进程3   </span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程3：%u\n&quot;</span>, getpid());  </span><br><span class="line">        sleep(<span class="number">2</span>);      </span><br><span class="line">        _exit(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="comment">///&lt; 父进程  </span></span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程：%u\n&quot;</span>, getpid());    </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)      </span><br><span class="line">        &#123;          </span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);     </span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) <span class="comment">///&lt; 有子进程退出    </span></span><br><span class="line">            &#123;             </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程：%d已退出\n&quot;</span>, ret);     </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) <span class="comment">///&lt; 没有子进程退出，继续等待    </span></span><br><span class="line">            &#123;              </span><br><span class="line">                <span class="keyword">continue</span>;    </span><br><span class="line">            &#125;           </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="comment">///&lt; 所有子进程以退出       </span></span><br><span class="line">            &#123;            </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;所有子进程已结束！\n&quot;</span>);          </span><br><span class="line">                <span class="keyword">break</span>;           </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【10】进程的补充</strong></p>
<p><strong>10.1 终端</strong></p>
<p>用户通过终端登录系统后得到一个 Shell 进程， 这个终端成为Shell 进程的控制终端（Controlling Terminal） ， 进程中， 控制终端是保存在 PCB中的信息。</p>
<p>案例1</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num); </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        ;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173839784.png"
                      alt="image-20240107173839784"
                ></p>
<p>案例2：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;   </span><br><span class="line">        sleep(<span class="number">5</span>);    </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程num=%d, 所属终端:%s\n&quot;</span>, num, ttyname(<span class="number">0</span>)); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;   </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程num=%d, 所属终端%s\n&quot;</span>, num, ttyname(<span class="number">0</span>)); </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173934286.png"
                      alt="image-20240107173934286"
                ></p>
<p>父进程先退出，控制权交给shell，导致子进程只能输出，不能输入。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107173953102.png"
                      alt="image-20240107173953102"
                ></p>
<p>#include &lt;unistd.h&gt;</p>
<p> char *ttyname(int fd);</p>
<p>功能： 由文件描述符查出对应的文件（终端）</p>
<p>参数：</p>
<p>fd： 文件描述符</p>
<p>返回值：</p>
<p>成功： 终端名</p>
<p>失败： NULL</p>
<p><strong>10.2 进程组</strong></p>
<p>一个或多个进程的集合。每个进程都属于一个进程组。</p>
<p>进程组 ID 为第一个进程 ID(组长进程)。 所以， 组长进程标识： 其进程组 ID为其进程 ID。</p>
<p>案例1：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)     </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174037036.png"
                      alt="image-20240107174037036"
                ></p>
<p>案例2：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">///&lt; 子进程  </span></span><br><span class="line">    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;子进程%d的组ID为：%d\n&quot;</span>, getpid(), getpgid(getpid()));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">///&lt; 父进程   </span></span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程%d的组ID为：%d\n&quot;</span>, getpid(), getpgid(getpid())); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)      </span><br><span class="line">        ;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174123799.png"
                      alt="image-20240107174123799"
                ></p>
<p>进程组结论：如果只是组长进程结束，当前进程组没有解散（组ID不变），只有进程组内的所有进程都结束，该进程组才会解散。</p>
<p>同时通过命令ps -ajx我们发现：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174214147.png"
                      alt="image-20240107174214147"
                ></p>
<p>通过上图我们发现：Shell、父进程、子进程的会话ID都一致，也就是说会话是多个进程组的集合。</p>
<p><strong>10.3会话</strong></p>
<p>多个进程组的集合</p>
<p>一个会话可以有一个控制终端。 这通常是终端设备或伪终端设备； 建立与控制终端连接的会话首进程被称为控制进程；</p>
<p>如果进程ID&#x3D;&#x3D;进程组ID&#x3D;&#x3D;会话ID，那么该进程为会话的首进程（会长）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174202652.png"
                      alt="image-20240107174202652"
                ></p>
<p><strong>创建会话注意事项 ：</strong></p>
<ol>
<li><p>调用进程不能是进程组组长， 该进程变成新会话首进程(session header) </p>
</li>
<li><p>该调用进程是组长进程， 则出错返回</p>
</li>
<li><p>该进程成为一个新进程组的组长进程 </p>
</li>
<li><p>需有 root 权限(ubuntu 不需要)</p>
</li>
<li><p>新会话丢弃原有的控制终端， 该会话没有控制终端</p>
</li>
<li><p>建立新会话时， 先调用 fork, 父进程终止， 子进程调用 setsid</p>
</li>
</ol>
<p><strong>setsid 函数：</strong></p>
<p>#include &lt;unistd.h&gt; </p>
<p>pid_t setsid(void);</p>
<p>功能：</p>
<p>创建一个会话， 并以自己的 ID 设置进程组 ID， 同时也是新会话的 ID。 调用了 setsid 函数的进程， 既是新的会长， 也是新的组长。</p>
<p>参数： 无</p>
<p>返回值：成功： 返回调用进程的会话 ID</p>
<p>失败： -1</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;      </span><br><span class="line">        setsid();    </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)         </span><br><span class="line">            ;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174523608.png"
                      alt="image-20240107174523608"
                ></p>
<p><strong>10.4制作守护进程</strong></p>
<p><strong>创建守护进程模型：</strong></p>
<ol>
<li><p>创建子进程， 父进程退出(必须) 所有工作在子进程中进行形式上脱离了控制终端 </p>
</li>
<li><p>在子进程中创建新会话(必须) setsid()函数 使子进程完全独立出来， 脱离控制</p>
</li>
<li><p>改变当前目录为根目录(不是必须) chdir()函数 防止占用可卸载的文件系统 也可以换成其它路径 </p>
</li>
<li><p>重设文件权限掩码(不是必须)umask()函数 防止继承的文件创建屏蔽字拒绝某些权限 增加守护进程灵活性</p>
</li>
</ol>
<p>5)关闭文件描述符(不是必须) 继承的打开文件不会用到， 浪费系统资源， 无法卸载</p>
<ol start="6">
<li>开始执行守护进程核心工作(必须) 守护进程退出处理程序模型</li>
</ol>
<p>示例：创建守护进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// 父进程退出   </span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)      </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);     <span class="comment">// 子进程创建会话(脱离原终端)  </span></span><br><span class="line">    setsid();     <span class="comment">// 改变工作目录（非必须， 如未改变就是进程运行目录）  </span></span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);     <span class="comment">//设置文件权限掩码(非必须)   </span></span><br><span class="line">    umask(<span class="number">0002</span>);     <span class="comment">//关闭文件描述符    </span></span><br><span class="line">    close(<span class="number">0</span>);  </span><br><span class="line">    close(<span class="number">1</span>);    </span><br><span class="line">    close(<span class="number">2</span>);     <span class="comment">//守护进程的核心工作 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="comment">//核心任务  </span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【11】vfork创建子进程</strong></p>
<p><strong>11.1vfork的介绍</strong></p>
<p>vfork 函数： 创建一个新进程。</p>
<p>pid_t vfork(void)</p>
<p>功能：</p>
<p>vfork 函数和 fork 函数一样都是在已有的进程中创建一个新的进程， 但它们创建的子进程是有区别的。</p>
<p>返回值:</p>
<p>创建子进程成功， 则在子进程中返回 0,父进程中返回子进程 ID。</p>
<p>​        出错则返回-1。</p>
<p><strong>11.2 vfork创建子进程的特点：</strong></p>
<p>vfork创建的子进程与父进程共享一块地址空间（跟创建多线程基本一致），子进程先运行（保证数据安全），</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174652832.png"
                      alt="image-20240107174652832"
                ></p>
<p>案例1：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;  </span><br><span class="line">    <span class="type">pid_t</span> pid = vfork();   </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;       </span><br><span class="line">        num = <span class="number">1000</span>;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程%d, num = %d\n&quot;</span>, getpid(), num);   </span><br><span class="line">        _exit(<span class="number">0</span>);  <span class="comment">///&lt; 显示调用  </span></span><br><span class="line">    &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)    </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程%d, num = %d\n&quot;</span>, getpid(), num);</span><br><span class="line">        &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174747156.png"
                      alt="image-20240107174747156"
                ></p>
<p><strong>11.3 vfork与fork的区别</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = vfork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;    </span><br><span class="line">        sleep(<span class="number">5</span>);   </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)  </span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d的i=%d\n&quot;</span>, getpid(), i);   </span><br><span class="line">            sleep(<span class="number">1</span>);     </span><br><span class="line">        &#125;        </span><br><span class="line">        _exit(<span class="number">0</span>); <span class="comment">///&lt; 显示调用 </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)    </span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程%d的i=%d\n&quot;</span>, getpid(), i); </span><br><span class="line">            sleep(<span class="number">1</span>);    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107174928656.png"
                      alt="image-20240107174928656"
                ></p>
<p><strong>知识点【12】exec函数族</strong></p>
<p><strong>12.1exec函数族概述</strong></p>
<p>如果通过运行的进程，启动另一个程序，需要用到exec函数族。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; </span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,cconst <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></div>

<p>l：表示exec函数的参数是通过列表(list)传递。</p>
<p>v：表示exec函数的参数是通过指针数组（vector）传递。</p>
<p>p:表示通过系统环境变量 查找命令（程序）</p>
<p>e: 可以使用系统环境变量</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL); ///&lt; 注意参数列表要以NULL结尾  </span></span><br><span class="line">    <span class="comment">// execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL); </span></span><br><span class="line">    <span class="comment">///&lt; 注意参数列表要以NULL结尾   </span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;   </span><br><span class="line">    <span class="comment">// execv(&quot;/bin/ls&quot;, args);    execvp(&quot;ls&quot;, args);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>12.2 exec函数族与当前进程的关系</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> iret = <span class="number">0</span>;   </span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用execvp之前\n&quot;</span>);    <span class="comment">//如果exec函数族执行成功，系统将会为该进程重新分配空间，保证exec的正确执行  </span></span><br><span class="line">    iret = execvp(<span class="string">&quot;ls&quot;</span>, args);  </span><br><span class="line">    <span class="keyword">if</span> (iret &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;execvp&quot;</span>);       </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;    <span class="comment">//exec下面的代码将不再执行  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用execvp之后\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181013467.png"
                      alt="image-20240107181013467"
                ></p>
<p><strong>exec 函数族与一般的函数不同， exec 函数族中的函数执行成功后不会返回</strong></p>
<p><strong>12.3exec函数族与vfork的关系</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   myexec.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">   &#123;    <span class="type">int</span> i =<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;其他进程%d,i=%d\n&quot;</span>,getpid(), i);</span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">主程序：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = vfork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的进程号%d\n&quot;</span>, getpid());   </span><br><span class="line">        execl(<span class="string">&quot;./myexec&quot;</span>, <span class="string">&quot;myexec&quot;</span>, <span class="literal">NULL</span>);   </span><br><span class="line">        _exit(<span class="number">0</span>); <span class="comment">///&lt; 显示调用 </span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)  </span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程%d的i=%d\n&quot;</span>, getpid(), i);  </span><br><span class="line">            sleep(<span class="number">1</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181146933.png"
                      alt="image-20240107181146933"
                ></p>
<p><strong>一个进程调用 exec 后， 除了进程 ID， 进程还保留了下列特征不变： 父进程号 进程组号 控制终端 根目录 当前工作目录 进程信号屏蔽集 未处理信号 …</strong></p>
<p><strong>扩展：system函数</strong></p>
<p>#include &lt;stdlib.h&gt;</p>
<p> int system(const char *command);</p>
<p>功能：</p>
<p>system 会调用 fork 函数产生子进程，子进程调用 exec 启动&#x2F;bin&#x2F;sh -c</p>
<p>string 来执行参数 string 字符串所代表的命令，此命令执行完后返回原调用进程。</p>
<p>参数：</p>
<p>要执行的命令的字符串。</p>
<p>返回值：（不许考虑  没意义）</p>
<p>如果 command 为 NULL，则 system()函数返回非 0，一般为 1。</p>
<p>如果 system()在调用&#x2F;bin&#x2F;sh 时失败则返回 127，其它失败原因返回-1。</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line"><span class="comment">// 通过system函数调用ls -l命令   </span></span><br><span class="line">	system(<span class="string">&quot;ls -l&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after system\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【13】进程间通信</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181305991.png"
                      alt="image-20240107181305991"
                ></p>
<p><strong>13.1文件描述符的复制</strong></p>
<p>   #include &lt;unistd.h&gt;</p>
<p>   int dup(int oldfd);  </p>
<p> int dup2(int oldfd, int newfd);</p>
<p><strong>1.dup函数</strong></p>
<p><strong>功能：从文件描述符表中寻找最小可用的文件描述符（通过返回值返回 oldfd的复制）</strong></p>
<p>案例：dup的使用1</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);   </span><br><span class="line">    <span class="type">int</span> fd = dup(<span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);   </span><br><span class="line">    write(fd, <span class="string">&quot;hello dup\n&quot;</span>, <span class="number">10</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>案例2：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;tmp&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>); </span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    close(<span class="number">1</span>);   </span><br><span class="line">    dup(fd);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.dup2函数（推荐）</strong></p>
<p><strong>功能:直接将newfd作为oldfd的复制品，如果newfd存在，将自动关闭newfd</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;tmp&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// close(1);    </span></span><br><span class="line">    <span class="comment">// dup(fd);   </span></span><br><span class="line">    dup2(fd, <span class="number">1</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello 1000phone!\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.2无名管道（pipe,管道）</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181453510.png"
                      alt="image-20240107181453510"
                ></p>
<p><strong>1.无名管道特点</strong></p>
<p>1、 半双工， 数据在同一时刻只能在一个方向上流动。</p>
<p> 2、 数据只能从管道的一端写入， 从另一端读出。 </p>
<p>3、 写入管道中的数据遵循先入先出的规则。</p>
<p> 4、 管道所传送的数据是无格式的， 这要求管道的读出方与写入方必须事先约定好数据的格式， 如多少字节算一个消息等。</p>
<p> 5、管道不是普通的文件， 不属于某个文件系统， 其只存在于内存中。</p>
<p> 6、 管道在内存中对应一个缓冲区。 不同的系统其大小不一定相同。</p>
<p> 7、 从管道读数据是一次性操作， 数据一旦被读走， 它就从管道中被抛弃， 释放空间以便写更多的数据。</p>
<p> 8、 管道没有名字， 只能在具有公共祖先的进程之间使用。</p>
<p><strong>2.创建无名管道</strong></p>
<p>#include &lt;unistd.h&gt; </p>
<p>int pipe(int filedes[2]);</p>
<p>功能： 经由参数 filedes 返回两个文件描述符</p>
<p>参数：</p>
<p>filedes 为 int 型数组的首地址， 其存放了管道的文件描述符 fd[0]、 fd[1]。</p>
<p>filedes[0]为读而打开， filedes[1]为写而打开管道， filedes[0]的输出是 filedes[1]的输入。</p>
<p>返回值：</p>
<p>成功： 返回 0</p>
<p>失败： 返回-1</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 创建无名管道    </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>]; </span><br><span class="line">    pipe(fd);     </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程 读  </span></span><br><span class="line">    &#123;      </span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端  </span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程%d,读到数据：%s\n&quot;</span>, getpid(), buf);   </span><br><span class="line">        close(fd[<span class="number">0</span>]);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程 写  </span></span><br><span class="line">    &#123;      </span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端 </span></span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">&quot;hello pipe!&quot;</span>, <span class="number">12</span>);  </span><br><span class="line">        close(fd[<span class="number">1</span>]);     </span><br><span class="line">        wait(<span class="literal">NULL</span>);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107181909314.png"
                      alt="image-20240107181909314"
                ></p>
<p><strong>3.无名管道读写特点</strong></p>
<p>1、 默认用 read 函数从管道中读数据是阻塞的（当写端关闭，读端自动解阻塞）。</p>
<p>2、 调用 write 函数向管道里写数据， 当缓冲区已满时 write 也会阻塞。 </p>
<p>3、 通信过程中， 读端口全部关闭后， 写进程向管道内写数据时， 写进程会（收到 SIGPIPE 信号） 退出。 </p>
<p>从管道中读数据的特点 编程时可通过 fcntl 函数设置文件的阻塞特性。 设置为阻塞： fcntl(fd, FSETFL, 0); 设置为非阻塞： fcntl(fd, FSETFL,O_NONBLOCK);</p>
<p>案例1：写阻塞</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;    <span class="comment">// 创建无名管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  </span><br><span class="line">    pipe(fd);    </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程 读  </span></span><br><span class="line">    &#123;      </span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端   </span></span><br><span class="line">        getchar();        </span><br><span class="line">        close(fd[<span class="number">0</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程 写 </span></span><br><span class="line">    &#123;    </span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)  </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;   </span><br><span class="line">            write(fd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);    </span><br><span class="line">        &#125;       </span><br><span class="line">        close(fd[<span class="number">1</span>]);   </span><br><span class="line">        wait(<span class="literal">NULL</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>案例2：写端关闭，读端自动解阻塞</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 创建无名管道   </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  </span><br><span class="line">    pipe(fd);    </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程 读 </span></span><br><span class="line">    &#123;     </span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端   </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)      </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">            <span class="type">int</span> len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child read len = %d\n&quot;</span>, len);     </span><br><span class="line">        &#125;     </span><br><span class="line">        close(fd[<span class="number">0</span>]);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程 写 </span></span><br><span class="line">    &#123;       </span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)    </span><br><span class="line">        &#123;          </span><br><span class="line">            sleep(<span class="number">3</span>);       </span><br><span class="line">            write(fd[<span class="number">1</span>], <span class="string">&quot;hello world&quot;</span>, <span class="number">11</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">        close(fd[<span class="number">1</span>]);     </span><br><span class="line">        wait(<span class="literal">NULL</span>); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>案例3：读端关闭，写端会受到SIGPIPE，退出写端进程</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 创建无名管道    </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];   </span><br><span class="line">    pipe(fd);   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程 读  </span></span><br><span class="line">    &#123;       </span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端 </span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)     </span><br><span class="line">        &#123;          </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;   </span><br><span class="line">            read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d,读到数据：%s\n&quot;</span>, getpid(), buf); </span><br><span class="line">            i++;    </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>)   </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;      </span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程 写 </span></span><br><span class="line">    &#123;       </span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端  </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)     </span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程%d写入\n&quot;</span>);  </span><br><span class="line">            write(fd[<span class="number">1</span>], <span class="string">&quot;hello pipe!&quot;</span>, <span class="number">12</span>);   </span><br><span class="line">            sleep(<span class="number">1</span>);      </span><br><span class="line">        &#125;       </span><br><span class="line">        close(fd[<span class="number">1</span>]);       </span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>4.综合案例</strong></p>
<p><strong>代码实现：ps -aux|grep bash</strong></p>
<p>分析：ps -aux –&gt;写入了1号文件</p>
<p>​    grep bash&lt;—–从0号文件读    </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 创建无名管道 </span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  </span><br><span class="line">    pipe(fd);    </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程 读 </span></span><br><span class="line">    &#123;      </span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端  </span></span><br><span class="line">        dup2(fd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">//把fd[0]重定向标准输入</span></span><br><span class="line">        execlp(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;grep&quot;</span>, <span class="string">&quot;bash&quot;</span>, <span class="literal">NULL</span>);   </span><br><span class="line">        close(fd[<span class="number">0</span>]);   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程 写  </span></span><br><span class="line">    &#123;      </span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端    </span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">//重定向  </span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;-aux&quot;</span>, <span class="literal">NULL</span>); </span><br><span class="line">        close(fd[<span class="number">1</span>]);      </span><br><span class="line">        wait(<span class="literal">NULL</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.3 有名管道（FIFO命名管道）</strong></p>
<p>有名管道用于无血缘关系的进程间通信</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107182953387.png"
                      alt="image-20240107182953387"
                ></p>
<p><strong>1.有名管道的特点</strong></p>
<p>1、 半双工， 数据在同一时刻只能在一个方向上流动。</p>
<p> 2、 写入 FIFO 中的数据遵循先入先出的规则。</p>
<p> 3、 FIFO 所传送的数据是无格式的， 这要求 FIFO 的读出方与写入方必须事先约定好数据的格式， 如多少字节算一个消息等。</p>
<p> 4、 FIFO 在文件系统中作为一个特殊的文件而存在， 但 FIFO 中的内容却存放在内存中。</p>
<p> 5、 管道在内存中对应一个缓冲区。 不同的系统其大小不一定相同。</p>
<p> 6、 从 FIFO 读数据是一次性操作， 数据一旦被读， 它就从 FIFO 中被抛弃， 释放空间以便写更多的数据。</p>
<p>7、 当使用 FIFO 的进程退出后， FIFO 文件将继续保存在文件系统中以便以后使用。</p>
<p>8、 FIFO 有名字， 不相关的进程可以通过打开命名管道进行通信。</p>
<p>管道文件大小永远为0</p>
<p><strong>2.mkfifo创建有名管道及读写</strong></p>
<p>include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;stat.h&gt;</p>
<p> int mkfifo( const char *pathname, mode_t mode);</p>
<p>参数：</p>
<p>pathname： FIFO 的路径名+文件名。</p>
<p>mode： mode_t 类型的权限描述符。</p>
<p>返回值：</p>
<p>成功： 返回 0</p>
<p>失败： 如果文件已经存在， 则会出错且返回-1。</p>
<p>write.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 创建有名管道,永远不要对mkfifo的返回值做判断 </span></span><br><span class="line">    mkfifo(<span class="string">&quot;fifo.txt&quot;</span>, <span class="number">0666</span>);     <span class="comment">//以写的方式打开有名管道（阻塞），阻塞到某进程以读的方式打开   </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;fifo.txt&quot;</span>, O_WRONLY); </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        perror(<span class="string">&quot;open fifo&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以写的方式打开\n&quot;</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;hello fifo&quot;</span>, <span class="number">10</span>);  </span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>read.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 创建有名管道,永远不要对mkfifo的返回值做判断  </span></span><br><span class="line">    mkfifo(<span class="string">&quot;fifo.txt&quot;</span>, <span class="number">0666</span>);     <span class="comment">// 以读的方式打开有名管道(阻塞)，阻塞到某个进程以写的方式打开    </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;fifo.txt&quot;</span>, O_RDONLY); </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)   </span><br><span class="line">    &#123;     </span><br><span class="line">        perror(<span class="string">&quot;open fifo&quot;</span>);   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以读的方式打开\n&quot;</span>);  </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;   </span><br><span class="line">    <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read len = %d, buf =%s\n&quot;</span>, len, buf);  </span><br><span class="line">    close(fd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.有名管道的读写特点</strong></p>
<p><strong>特点一：open打开有名管道，不指定 O_NONBLOCK(阻塞)</strong></p>
<p>1、 open 以只读方式打开 FIFO 时， 要阻塞到某个进程为写而打开此 FIFO</p>
<p> 2、 open 以只写方式打开 FIFO 时， 要阻塞到某个进程为读而打开此 FIFO。</p>
<p> 3、 open 以只读、 只写方式打开 FIFO 时会阻塞， 调用 read 函数从 FIFO 里读数据时 read 也会阻塞。</p>
<p> 4、 通信过程中若写进程先退出了， 则调用 read 函数从 FIFO 里读数据时不阻塞； 若写进程又重新运行， 则调用 read 函数从 FIFO 里读数据时又恢复阻塞。 </p>
<p>5、 通信过程中， 读进程退出后， 写进程向命名管道内写数据时， 写进程也会（收到 SIGPIPE 信号） 退出。 </p>
<p>6、 调用 write 函数向 FIFO 里写数据， 当缓冲区已满时 write 也会阻塞。</p>
<p><strong>特点二：open打开有名管道，指定O_NONBLOCK(非阻塞)</strong></p>
<p>1、 先以只读方式打开： 如果没有进程已经为写而打开一个 FIFO, 只读 open 成功， 并且 open 不阻塞。</p>
<p>2、 先以只写方式打开： 如果没有进程已经为读而打开一个 FIFO， 只写 open 将出错返回-1。</p>
<p>3、read、 write 读写命名管道中读数据时不阻塞。 </p>
<p>4、 通信过程中， 读进程退出后，写进程向命名管道内写数据时， 写进程也会（收到 SIGPIPE 信号） 退出。</p>
<p><strong>注意：open 函数以可读可写方式打开 FIFO 文件时的特点：</strong></p>
<p>1、 open 不阻塞。</p>
<p>2、 调用 read 函数从 FIFO 里读数据时 read 会阻塞。</p>
<p>3、 调用 write 函数向 FIFO 里写数据， 当缓冲区已满时 write 也会阻塞。</p>
<p><strong>write.c</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 创建有名管道,永远不要对mkfifo的返回值做判断 </span></span><br><span class="line">    mkfifo(<span class="string">&quot;fifo.txt&quot;</span>, <span class="number">0666</span>);     <span class="comment">// 以写的方式打开有名管道（阻塞），阻塞到某进程以读的方式打开   </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;fifo.txt&quot;</span>, O_WRONLY); </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;open fifo&quot;</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以写的方式打开\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;      </span><br><span class="line">        write(fd, <span class="string">&quot;hello fifo&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">    close(fd);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>read.c</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 创建有名管道,永远不要对mkfifo的返回值做判断  </span></span><br><span class="line">    mkfifo(<span class="string">&quot;fifo.txt&quot;</span>, <span class="number">0666</span>);     <span class="comment">// 以读的方式打开有名管道(阻塞)，阻塞到某个进程以写的方式打开    </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;fifo.txt&quot;</span>, O_RDONLY);  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;open fifo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以读的方式打开\n&quot;</span>);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;   </span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;   </span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read len = %d, buf =%s\n&quot;</span>, len, buf);  </span><br><span class="line">    &#125;   </span><br><span class="line">    close(fd);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>题目： 实现单机 聊天 提示： 父进程创建子进程， 实现多任务。 父进程负责发信息(向 FIFO 里写数据)， 子进程负责接收信息( 从 FIFO 里读数据)。 打开命名管道的用阻塞的方法打开。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107183232779.png"
                      alt="image-20240107183232779"
                ></p>
<p>lucy.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    mkfifo(<span class="string">&quot;l_2_b&quot;</span>, <span class="number">0666</span>);  </span><br><span class="line">    mkfifo(<span class="string">&quot;b_2_l&quot;</span>, <span class="number">0666</span>);  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)   </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">pid_t</span> pid = fork(); </span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)       </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">// 写  </span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;l_2_b&quot;</span>, O_WRONLY);     </span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)    </span><br><span class="line">        &#123;        </span><br><span class="line">            perror(<span class="string">&quot;open&quot;</span>);      </span><br><span class="line">            _exit(<span class="number">-1</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">        &#123;          </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">            fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);  </span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;      </span><br><span class="line">            write(fd, buf, <span class="built_in">strlen</span>(buf));     </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;bye&quot;</span>) == <span class="number">0</span>)       </span><br><span class="line">                <span class="keyword">break</span>;        &#125;       </span><br><span class="line">        close(fd);     </span><br><span class="line">        _exit(<span class="number">0</span>);  </span><br><span class="line">    &#125;    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">// 读    </span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;b_2_l&quot;</span>, O_RDONLY); </span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)   </span><br><span class="line">        &#123;        </span><br><span class="line">            perror(<span class="string">&quot;open&quot;</span>);       </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">        &#123;     </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;    </span><br><span class="line">            <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));    </span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)     </span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;RECV:%s\n&quot;</span>, buf);     </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;bye&quot;</span>) == <span class="number">0</span>)    </span><br><span class="line">                &#123;          </span><br><span class="line">                    <span class="keyword">break</span>;         </span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="keyword">else</span>       </span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        close(fd); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);    </span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)      </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程%d已退出\n&quot;</span>, ret);   </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)         </span><br><span class="line">                <span class="keyword">continue</span>;       </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)        </span><br><span class="line">                <span class="keyword">break</span>;      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>bob.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    mkfifo(<span class="string">&quot;l_2_b&quot;</span>, <span class="number">0666</span>);  </span><br><span class="line">    mkfifo(<span class="string">&quot;b_2_l&quot;</span>, <span class="number">0666</span>); </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">pid_t</span> pid = fork(); </span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)     </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="comment">// 写 </span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;b_2_l&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)     </span><br><span class="line">        &#123;      </span><br><span class="line">            perror(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);   </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;      </span><br><span class="line">            fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;     </span><br><span class="line">            write(fd, buf, <span class="built_in">strlen</span>(buf));   </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;bye&quot;</span>) == <span class="number">0</span>)    </span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">        &#125;      </span><br><span class="line">        close(fd);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="comment">// 读  </span></span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;l_2_b&quot;</span>, O_RDONLY); </span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)     </span><br><span class="line">        &#123;      </span><br><span class="line">            perror(<span class="string">&quot;open&quot;</span>);    </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);      </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">        &#123;         </span><br><span class="line">            <span class="type">char</span> buf[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;     </span><br><span class="line">            <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)   </span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;RECV:%s\n&quot;</span>, buf);   </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;bye&quot;</span>) == <span class="number">0</span>)   </span><br><span class="line">                &#123;           </span><br><span class="line">                    <span class="keyword">break</span>;      </span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">else</span>     </span><br><span class="line">                <span class="keyword">break</span>;      </span><br><span class="line">        &#125;     </span><br><span class="line">        close(<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        &#123;     </span><br><span class="line">            <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG); </span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)       </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程%d已退出\n&quot;</span>, ret);   </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)        </span><br><span class="line">                <span class="keyword">continue</span>;        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)         </span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.4消息队列</strong></p>
<p>进程间多对多通信选择消息队列。存放在内存中，由内核维护。</p>
<p><strong>1.消息队列特点</strong></p>
<p>1、 消息队列中的消息是有类型的。</p>
<p> 2、 消息队列中的消息是有格式的。</p>
<p> 3、 消息队列可以实现消息的随机查询。 消息不一定要以先进先出的次序读取， 编程时可以按消息的类型读取。</p>
<p> 4、 消息队列允许一个或多个进程向它写入或者读取消息。</p>
<p> 5、 与无名管道、 命名管道一样， 从消息队列中读出消息， 消息队列中对应的数据都会被删除。</p>
<p> 6、 每个消息队列都有消息队列标识符， 消息队列的标识符在整个系统中是唯一的。</p>
<p>7、 只有内核重启或人工删除消息队列时， 该消息队列才会被删除。 若不人工删除消息队列， 消息队列会一直存在于系统中。</p>
<p><strong>2.消息队列的相关API</strong></p>
<p>1)获取唯一的key值（键值）</p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;ipc.h&gt; </p>
<p>key_t ftok(const char *pathname, int proj_id)；</p>
<p>功能：</p>
<p>获得项目相关的唯一的 IPC 键值。</p>
<p>参数：</p>
<p>pathname： 路径名  &#x2F;&#x2F;&#x2F;&lt; “&#x2F;“</p>
<p>proj_id： 项目 ID， 非 0 整数(只有低 8 位有效) </p>
<p>返回值：</p>
<p>成功返回 key 值， </p>
<p>失败返回 -1。</p>
<p>key_t key &#x3D; ftok(“&#x2F;“, 2023); </p>
<p>2)根据唯一的key值创建消息队列</p>
<p>#include &lt;sys&#x2F;msg.h&gt;</p>
<p> int msgget(key_t key, int msgflg)；</p>
<p>功能：</p>
<p>创建一个新的或打开一个已经存在的消息队列。 不同的进程调用此函数，只要用相同的 key 值就能得到同一个消息队列的标识符。</p>
<p>参数：</p>
<p>key： IPC 键值。</p>
<p>msgflg： 标识函数的行为及消息队列的权限。</p>
<p>参数:</p>
<p>msgflg 的取值：</p>
<p>IPC_CREAT： 创建消息队列。</p>
<p>IPC_EXCL：  检测消息队列是否存在。</p>
<p>位或权限位： 消息队列位或权限位后可以设置消息队列的访问权限， 格式和 open 函数的mode_t 一样， 但可执行权限未使用。</p>
<p>返回值：</p>
<p>成功： 消息队列的标识符，</p>
<p>失败： 返回-1。</p>
<p>查看消息队列命令：ipcs  -q</p>
<p>3）消息队列格式：</p>
<p>typedef struct _msg {    long mtype; &#x2F;<em>消息类型 必须是第一个成员，数据类型必须是long</em>&#x2F;    char mtext[100]; &#x2F;<em>消息正文 用户自定义</em>&#x2F;    … &#x2F;<em>消息的正文可以有多个成员</em>&#x2F; }MSG;</p>
<p>4)发送消息：msgsnd</p>
<p>#include &lt;sys&#x2F;msg.h&gt; </p>
<p>int msgsnd(int msqid, const void *msgp,size_t msgsz, int msgflg);</p>
<p>功能：</p>
<p>将新消息添加到消息队列。</p>
<p>参数：</p>
<p>msqid： 消息队列的标识符。</p>
<p>msgp： 待发送消息结构体的地址。</p>
<p>msgsz： 消息正文的字节数。</p>
<p>msgflg： 函数的控制属性</p>
<p>0： msgsnd 调用阻塞直到条件满足为止。(推荐)</p>
<p>IPC_NOWAIT: 若消息没有立即发送则调用该函数的进程会立即返回。</p>
<p>返回值：</p>
<p>成功： 0； 失败： 返回-1。</p>
<p>5）接收消息：msgrcv</p>
<p>#include &lt;sys&#x2F;msg.h&gt; ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);</p>
<p>功能：</p>
<p>从标识符为 msqid 的消息队列中接收一个消息。 一旦接收消息成功， 则消息在消息队列中被删除。</p>
<p>参数：</p>
<p>msqid： 消息队列的标识符， 代表要从哪个消息列中获取消息。</p>
<p>msgp： 存放消息结构体的地址。</p>
<p>msgsz： 消息正文的字节数。</p>
<p>msgtyp： 消息的类型、 可以有以下几种类型</p>
<p>msgtyp &#x3D; 0： 返回队列中的第一个消息</p>
<p>msgtyp &gt; 0： 返回队列中消息类型为 msgtyp 的消息</p>
<p>msgtyp &lt; 0： 返回队列中消息类型值小于或等于 msgtyp 绝对值的消息， 如果这种消息有若干个， 则取类型值 最小的消息。</p>
<p>注意：</p>
<p>若消息队列中有多种类型的消息， msgrcv 获取消息的时候按消息类型获取， 不是先进先出的。</p>
<p>在获取某类型消息的时候， 若队列中有多条此类型的消息， 则获取最先添加的消息， 即先进先出原则。</p>
<p>msgflg： 函数的控制属性</p>
<p>0： msgrcv 调用阻塞直到接收消息成功为止。（推荐）</p>
<p>MSG_NOERROR:若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节,且不通知消息发送进程。</p>
<p>IPC_NOWAIT:调用进程会立即返回。 若没有收到消息则立即返回-1。</p>
<p>返回值：</p>
<p>成功：返回读取消息的长度， 失败：返回-1</p>
<p>7）消息队列控制函数:msgctl</p>
<p>#include &lt;sys&#x2F;msg.h&gt;</p>
<p> int msgctl(int msqid, int cmd, struct msqid_ds *buf);</p>
<p>功能：</p>
<p>对消息队列进行各种控制， 如修改消息队列的属性， 或删除消息消息队列。</p>
<p>参数：</p>
<p>msqid： 消息队列的标识符。</p>
<p>cmd： 函数功能的控制。</p>
<p>buf： msqid_ds 数据类型的地址， 用来存放或更改消息队列的属性。</p>
<p>cmd： 函数功能的控制</p>
<p>IPC_RMID： 删除由 msqid 指示的消息队列， 将它从系统中删除并破坏相关数据结构。</p>
<p>IPC_STAT： 将 msqid 相关的数据结构中各个元素的当前值存入到由 buf指向的结构中。</p>
<p>IPC_SET： 将 msqid 相关的数据结构中的元素设置为由 buf 指向的结构中的对应值。</p>
<p>返回值： 成功： 返回 0； 失败： 返回 -1</p>
<p><strong>3.案例：lucy bob tom互发信息（lucy负责发送、bob负责接收类型为10的信息、tom负责接收类型为20的消息）</strong></p>
<p>lucy.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">msg</span> &#123;</span>  </span><br><span class="line">    <span class="type">long</span> mtype;    <span class="comment">// 消息类型   </span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>]; <span class="comment">// 消息正文   </span></span><br><span class="line">    <span class="type">char</span> text[<span class="number">64</span>]; <span class="comment">// 消息正文 </span></span><br><span class="line">&#125; MSG; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 获取唯一的key值  </span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/&quot;</span>, <span class="number">2023</span>); </span><br><span class="line">    <span class="comment">// printf(&quot;key = %d\n&quot;, key);    </span></span><br><span class="line">    <span class="comment">// 创建消息队列   </span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, IPC_CREAT | <span class="number">0666</span>);  </span><br><span class="line">    MSG msg;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;(msg.mtype));   </span><br><span class="line">    <span class="built_in">strcpy</span>(msg.name, <span class="string">&quot;lucy&quot;</span>);  </span><br><span class="line">    <span class="built_in">strcpy</span>(msg.text, <span class="string">&quot;一起吃晚饭&quot;</span>);  </span><br><span class="line">    msgsnd(msgid, &amp;msg, <span class="keyword">sizeof</span>(MSG) - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>bob.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">msg</span> </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">long</span> mtype;    <span class="comment">// 消息类型  </span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>]; <span class="comment">// 消息正文  </span></span><br><span class="line">    <span class="type">char</span> text[<span class="number">64</span>]; <span class="comment">// 消息正文 &#125;</span></span><br><span class="line">    MSG; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">key_t</span> key = ftok(<span class="string">&quot;/&quot;</span>, <span class="number">2023</span>); </span><br><span class="line">        <span class="type">int</span> msgid = msgget(key, IPC_CREAT | <span class="number">0666</span>); </span><br><span class="line">        MSG msg;  </span><br><span class="line">        msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(MSG) - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">10</span>, <span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送者姓名：%s,消息：%s\n&quot;</span>, msg.name, msg.text);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>tom.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span>    <span class="type">long</span> mtype;    <span class="comment">// 消息类型    </span></span><br><span class="line"> <span class="type">char</span> name[<span class="number">32</span>]; <span class="comment">// 消息正文  </span></span><br><span class="line"> <span class="type">char</span> text[<span class="number">64</span>]; <span class="comment">// 消息正文 </span></span><br><span class="line">&#125; MSG;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/&quot;</span>, <span class="number">2023</span>);   </span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, IPC_CREAT | <span class="number">0666</span>);   </span><br><span class="line">    MSG msg;  </span><br><span class="line">    msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(MSG) - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">20</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发送者姓名：%s,消息：%s\n&quot;</span>, msg.name, msg.text);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>作业：题目： 消息队列实现多人聊天程序 提示：</p>
<p>消息结构体类型 typedef struct msg { long type; &#x2F;&#x2F;接收者类型 char text[100]; &#x2F;&#x2F;发送内容 char name[20]; &#x2F;&#x2F;发送者姓名 }MSG;</p>
<p>每个程序都有两个任务， 一个任务是负责接收消息， 一个任务是负责发送消息， 通过 fork 创建子进程实现多任务。 一个进程负责接收信息， 它只接收某种类型的消息， 只要别的进程发送此类型的消息， 此进程就能收到。 收到后通过消息的name 成员就可知道是谁发送的消息。 另一个进程负责发信息， 可以通过输入来决定发送消息的类型。 设计程序的时候， 接收消息的进程接收消息的类型不一样， 这样就实现了发送的消息只被接收此类型消息的人收到， 其它人收不到。 这样就是实现了给特定的人发送消息。</p>
<p>代码框架类似于如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107184929545.png"
                      alt="image-20240107184929545"
                ></p>
<p>lucy.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">msg</span> </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="type">long</span> mtype;    <span class="comment">// 消息类型  </span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>]; <span class="comment">// 消息正文 </span></span><br><span class="line">    <span class="type">char</span> text[<span class="number">64</span>]; <span class="comment">// 消息正文 &#125; </span></span><br><span class="line">    MSG; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 获取唯一的key值   </span></span><br><span class="line">        <span class="type">key_t</span> key = ftok(<span class="string">&quot;/&quot;</span>, <span class="number">2020</span>); </span><br><span class="line">        <span class="comment">// printf(&quot;key = %d\n&quot;, key);</span></span><br><span class="line">        <span class="comment">// 创建消息队列</span></span><br><span class="line">        <span class="type">int</span> msgid = msgget(key, IPC_CREAT | <span class="number">0666</span>);  </span><br><span class="line">        MSG msg;  </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">        &#123;     </span><br><span class="line">            <span class="type">pid_t</span> pid = fork(); </span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>)   </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) </span><br><span class="line">            <span class="comment">// 子进程1  写   </span></span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)     </span><br><span class="line">            &#123;        </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%ld %s&quot;</span>, &amp;(msg.mtype), msg.text);   </span><br><span class="line">                <span class="built_in">strcpy</span>(msg.name, <span class="string">&quot;lucy&quot;</span>);    </span><br><span class="line">                msgsnd(msgid, &amp;msg, <span class="keyword">sizeof</span>(MSG) - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>); </span><br><span class="line">            &#125;     </span><br><span class="line">            _exit(<span class="number">0</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) </span><br><span class="line">            <span class="comment">// 子进程2 读   </span></span><br><span class="line">        &#123;      </span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">            &#123;          </span><br><span class="line">                <span class="type">int</span> len = msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(MSG) - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">10</span>, <span class="number">0</span>);  </span><br><span class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)   </span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;接收到%s的信息:%s\n&quot;</span>, msg.name, msg.text); </span><br><span class="line">            &#125;   </span><br><span class="line">            _exit(<span class="number">-1</span>);  </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="comment">// 父进程   </span></span><br><span class="line">        &#123;     </span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="type">pid_t</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);    </span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)         </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;子进程%d退出！n&quot;</span>, ret);  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)   </span><br><span class="line">                    <span class="keyword">continue</span>;     </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                    <span class="keyword">break</span>;     </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.5mmap存储映射（磁盘映射）</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185119746.png"
                      alt="image-20240107185119746"
                ></p>
<p>存储映射I&#x2F;O,使一个磁盘文件与存储空间中的一个缓冲区相映射。</p>
<p><strong>1.mmap映射：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185130149.png"
                      alt="image-20240107185130149"
                ></p>
<p>将磁盘文件的某块区域存储空间的一个缓冲区相映射。</p>
<p><strong>2.相关API</strong></p>
<p><strong>1）mmap函数</strong></p>
<p>建立映射区:</p>
<p>#include &lt;sys&#x2F;mman.h&gt; </p>
<p>void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</p>
<p>参数：</p>
<p>addr 地址， 填 NULL</p>
<p>length 长度 要申请的映射区的长度</p>
<p>prot 权限</p>
<p>PROT_READ 可读</p>
<p>PROT_WRITE 可写</p>
<p>flags 标志位</p>
<p>MAP_SHARED 共享的 – 对映射区的修改会影响源文件</p>
<p>MAP_PRIVATE 私有的</p>
<p>fd 文件描述符 需要打开一个文件</p>
<p>offset 指定一个偏移位置 ， 从该位置开始映射(0)</p>
<p>返回值</p>
<p>成功 返回映射区的首地址</p>
<p>失败 返回 MAP_FAILED ((void *) -1)</p>
<p><strong>2)munmap解除映射（释放映射区）</strong></p>
<p>int munmap(void *addr, size_t length);</p>
<p>参数：</p>
<p>addr 映射区的首地址（mmap的返回值）</p>
<p>length 映射区的长度（mmap时的参数length）</p>
<p>返回值</p>
<p>成功 返回 0</p>
<p>失败 返回 -1</p>
<p><strong>3）truncate拓展文件大小</strong></p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>int truncate(const char *path, off_t length);</p>
<p>path 要拓展的文件</p>
<p>length 要拓展的长度</p>
<p>案例：</p>
<p>write.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>]; </span><br><span class="line">    <span class="type">int</span> age;   </span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; <span class="type">student_t</span>, *<span class="type">pstudent_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mmap&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);   </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        perror(<span class="string">&quot;open mmap&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;     <span class="comment">// 拓展文件大小 </span></span><br><span class="line">    truncate(<span class="string">&quot;mmap&quot;</span>, <span class="number">128</span>); </span><br><span class="line">    <span class="comment">// student_t * stu = (student_t *) </span></span><br><span class="line">    <span class="type">pstudent_t</span> stu = (<span class="type">pstudent_t</span>)mmap(<span class="literal">NULL</span>, <span class="number">128</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">strcpy</span>(stu-&gt;name, <span class="string">&quot;lucy&quot;</span>);  </span><br><span class="line">    stu-&gt;age = <span class="number">19</span>;  </span><br><span class="line">    stu-&gt;score = <span class="number">95.6f</span>;  </span><br><span class="line">    munmap(stu, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>read.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];   </span><br><span class="line">    <span class="type">int</span> age;    </span><br><span class="line">    <span class="type">float</span> score; </span><br><span class="line">&#125; <span class="type">student_t</span>, *<span class="type">pstudent_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mmap&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>); </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)   </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;open mmap&quot;</span>);   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 拓展文件大小   </span></span><br><span class="line">    truncate(<span class="string">&quot;mmap&quot;</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// student_t * stu = (student_t *)  </span></span><br><span class="line">    <span class="type">pstudent_t</span> stu = (<span class="type">pstudent_t</span>)mmap(<span class="literal">NULL</span>, <span class="number">128</span>, PROT_READ | PROT_WRITE, MAP_SHARED,                                      fd, <span class="number">0</span>);   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">// 读取之后数据依然存在  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;姓名:%s, 年龄:%d, 成绩:%.2f\n&quot;</span>, stu-&gt;name, stu-&gt;age, stu-&gt;score);     </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">    munmap(stu, <span class="number">128</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.6 共享内存(效率最高，速度最快)</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185659786.png"
                      alt="image-20240107185659786"
                ></p>
<p>共享内存允许两个或多个进程共享给定的存储区域。</p>
<p><strong>1.共享内存的特点</strong></p>
<p>特点：</p>
<p>1、 共享内存是进程间共享数据的一种最快的方法。 一个进程向共享的内存区域写入了数据， 共享这个内存区域的所有进程就可以立刻看到其中的内容。</p>
<p> 2、 使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107185713739.png"
                      alt="image-20240107185713739"
                ></p>
<p><strong>2.ubuntu部分版本的限制</strong></p>
<p>在 ubuntu 部分版本中共享内存限制值如下 共享存储区的最小字节数： 1 共享存储区的最大字节数： 32M 共享存储区的最大个数： 4096 每个进程最多能映射的共享存储区的个数： 4096</p>
<p><strong>3.共享内存的API</strong></p>
<p>1）获取共享内存标识符</p>
<p>#include &lt;sys&#x2F;ipc.h&gt;</p>
<p> #include &lt;sys&#x2F;shm.h&gt;</p>
<p> int shmget(key_t key, size_t size,int shmflg);</p>
<p>功能:创建或打开一块共享内存区</p>
<p>参数：</p>
<p>key： IPC 键值(ftok())</p>
<p>size： 该共享存储段的长度(字节)</p>
<p>shmflg： 标识函数的行为及共享内存的权限。</p>
<p>参数:</p>
<p>shmflg：</p>
<p>IPC_CREAT： 如果不存在就创建</p>
<p>IPC_EXCL： 如果已经存在则返回失败</p>
<p>位或权限位： 共享内存位或权限位后可以设置共享内存的访问权限， 格式和 open 函数的 mode_t 一样， 但可执行权限未使用。</p>
<p>返回值:</p>
<p>成功：返回共享内存标识符。</p>
<p>失败： 返回－1。</p>
<p>查看共享内存 ipcs  -m</p>
<p>2)共享区映射:</p>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p> #include &lt;sys&#x2F;shm.h&gt;</p>
<p> void *shmat(int shmid, const void *shmaddr,int shmflg);</p>
<p>功能：</p>
<p>将一个共享内存段映射到调用进程的数据段中。</p>
<p>参数：</p>
<p>shmid： 共享内存标识符。</p>
<p>shmaddr： 共享内存映射地址(若为 NULL 则由系 统自动指定)， 推荐使用 NULL。</p>
<p>shmflg： 共享内存段的访问权限和映射条件</p>
<p>0： 共享内存具有可读可写权限。</p>
<p>SHM_RDONLY： 只读。</p>
<p>SHM_RND： （shmaddr 非空时才有效）</p>
<p>没有指定 SHM_RND 则此段连接到 shmaddr 所指定的地址上(shmaddr 必需页对齐)。</p>
<p>指定了 SHM_RND 则此段连接到 shmaddr- shmaddr%SHMLBA 所表示的地址上。</p>
<p>返回值：</p>
<p>成功： 返回共享内存段映射地址</p>
<p>失败： 返回 -1</p>
<p>注意: shmat 函数使用的时候第二个和第三个参数一般设为 NULL 和 0， 即系统自动指定共享内存地址， 并且共享内存可读可写.</p>
<p><strong>4)解除共享映射区</strong></p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;sys&#x2F;shm.h&gt; </p>
<p>int shmdt(const void *shmaddr);</p>
<p>功能：</p>
<p>将共享内存和当前进程分离(仅仅是断开联系并不删除共享内存)。</p>
<p>参数：</p>
<p>shmaddr： 共享内存映射地址。</p>
<p>返回值：</p>
<p>成功返回 0，</p>
<p> 失败返回 -1。</p>
<p><strong>5)共享内存控制</strong></p>
<p>#include &lt;sys&#x2F;ipc.h&gt;</p>
<p> #include &lt;sys&#x2F;shm.h&gt;</p>
<p> int shmctl(int shmid, int cmd,struct shmid_ds *buf);</p>
<p>功能： 共享内存空间的控制。</p>
<p>参数：</p>
<p>shmid： 共享内存标识符。</p>
<p>cmd： 函数功能的控制。</p>
<p>buf： shmid_ds 数据类型的地址， 用来存放或修改共享内存的属性。</p>
<p>cmd： 函数功能的控制</p>
<p>IPC_RMID： 删除。</p>
<p>IPC_SET： 设置 shmid_ds 参数。</p>
<p>IPC_STAT： 保存 shmid_ds 参数。</p>
<p>SHM_LOCK： 锁定共享内存段(超级用户)。</p>
<p>SHM_UNLOCK： 解锁共享内存段。</p>
<p>返回值：</p>
<p>成功返回 0， 失败返回 -1。</p>
<p>案例：</p>
<p>write.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 1.获取唯一键值   </span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/&quot;</span>, <span class="number">2024</span>);  </span><br><span class="line">    <span class="comment">// 2.根据键值获取共享内存标识符   </span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="number">30</span>, IPC_CREAT | <span class="number">0666</span>); </span><br><span class="line">    <span class="comment">// 3.建立内存映射区  </span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);   </span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world&quot;</span>);    </span><br><span class="line">    <span class="comment">// 4.共享解除映射区  </span></span><br><span class="line">    shmdt(p);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>read.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 1.获取唯一键值  </span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/&quot;</span>, <span class="number">2024</span>);    </span><br><span class="line">    <span class="comment">// 2.根据键值获取共享内存标识符 </span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="number">30</span>, IPC_CREAT | <span class="number">0666</span>);  </span><br><span class="line">    <span class="comment">// 3.建立内存映射区   </span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);   </span><br><span class="line">    sleep(<span class="number">5</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);   </span><br><span class="line">    <span class="comment">// 4.共享解除映射区 </span></span><br><span class="line">    shmdt(p); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.7信号</strong></p>
<p><strong>1.信号的概念</strong></p>
<p>信号是 Linux 进程间通信的最古老的方式。 信号是软件中断， 它是在软件层次上对中断机制的一种模拟， 是一种异步通信的方式。</p>
<p><strong>2.信号的特点</strong></p>
<p>简单、不能携带大量数据、满足特定条件才发出。</p>
<p><strong>3.一个信号的完整周期</strong></p>
<p>信号的注册（除系统信号）、信号的产生(如_exit)、信号处理函数（方式：默认的、忽略、自定义处理函数）、信号的注销。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190049758.png"
                      alt="image-20240107190049758"
                ></p>
<p>注意： 这里信号的产生， 注册， 注销时信号的内部机制， 而不是信号的函数实现。</p>
<p><strong>4.信号的编号</strong></p>
<p>Linux 可使用命令： kill -l（”l” 为字母） ， 查看相应的信号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190106177.png"
                      alt="image-20240107190106177"
                ></p>
<p>不存在编号为 0 的信号。 其中 1-31 号信号称之为常规信号（也叫普通信号或标准信号） ， 34-64 称之为实时信号， 驱动编程与硬件相关。 名字上区别不大。 而前32 个名字各不相同。</p>
<p>每个信号必备 4 要素， 分别是： 1)编号  2）名称  3）事件  4）默认处理动作</p>
<p>注意：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</p>
<p><strong>5.信号的产生和处理</strong></p>
<p><strong>信号产生</strong></p>
<p> a) 当用户按某些终端键时， 将产生信号。 终端上按“Ctrl+c”组合键通常产生中断信号 SIGINT 终端上按“Ctrl+\”键通常产生中断信号 SIGQUIT 终端上按“Ctrl+z”键通常产生中断信号 SIGSTOP 等。</p>
<p> b) 硬件异常将产生信号。 除数为0， 无效的内存访问等。 这些情况通常由硬件检测到， 并通知内核， 然后内核产生适当的信号发送给相应的进程。</p>
<p> c) 软件异常将产生信号。 当检测到某种软件条件已发生(如： 定时器 alarm)， 并将其通知有关进程时， 产生信号。</p>
<p> d) 调用系统函数(如： kill、 raise、 abort)将发送信号。 注意： 接收信号进程和发送信号进程的所有者必须相同， 或发送信号进程的所有者必须是超级用户。</p>
<p> e) 运行 kill&#x2F;killall 命令将发送信号。 此程序实际上是使用 kill 函数来发送信号。 也常用此命令终止一个失控的后台进程（命令kill -9 进程号，用于杀死进程号指定的进程；killall 进程名称，杀死进程名称指定的进程）。</p>
<p><strong>13.8未决信号集和阻塞信号集</strong></p>
<p>阻塞信号集：推迟处理的信号集合。</p>
<p>未决信号集：未被处理的信号集合。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190129138.png"
                      alt="image-20240107190129138"
                ></p>
<p><strong>13.9 发送信号API</strong></p>
<p><strong>1.kill给指定的进程发出信号</strong></p>
<p>#include &lt;sys&#x2F;types.h&gt; </p>
<p>#include &lt;signal.h&gt; </p>
<p>int kill(pid_t pid, int sig);</p>
<p>功能： 给指定进程发送指定信号(不一定杀死)</p>
<p>参数：</p>
<p>pid : 取值有 4 种情况 :</p>
<p>pid &gt; 0: 将信号传送给进程 ID 为 pid 的进程。</p>
<p>pid &#x3D; 0 : 将信号传送给当前进程所在进程组中的所有进程。</p>
<p>pid &#x3D; -1 : 将信号传送给系统内所有的进程。</p>
<p>pid &lt; -1 : 将信号传给指定进程组的所有进程。 这个进程组号等于 pid 的绝对值。</p>
<ul>
<li>sig : 信号的编号， 这里可以填数字编号， 也可以填信号的宏定义， 可以通过命令 kill - l(“l” 为字母)进行相应查看。 不推荐直接使用数字， 应使用宏名， 因为不同操作系统信号编号可能不同， 但名称一致。</li>
</ul>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： -1</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程%d玩游戏\n&quot;</span>, getpid());   </span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;给你5秒钟去做作业！\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>); </span><br><span class="line">        kill(pid, SIGKILL);  </span><br><span class="line">        wait(<span class="literal">NULL</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.raise函数</strong></p>
<p>#include &lt;signal.h&gt;</p>
<p> int raise(int sig);</p>
<p>功能： 给当前进程发送指定信号(自己给自己发)， 等价于 kill(getpid(), sig)</p>
<p>参数：</p>
<p>sig： 信号编号</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;5秒后退出&quot;</span>); </span><br><span class="line">     sleep(<span class="number">5</span>); </span><br><span class="line">     raise(SIGINT); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++\n&quot;</span>);  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.abort 函数</strong></p>
<p>#include &lt;stdlib.h&gt;</p>
<p> void abort(void);</p>
<p>功能： 给自己发送异常终止信号 6) SIGABRT， 并产生 core 文件， 等价于 kill(getpid(), SIGABRT);</p>
<p>参数： 无</p>
<p>返回值： 无</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5秒后退出\n&quot;</span>);   </span><br><span class="line">    sleep(<span class="number">5</span>);   </span><br><span class="line">    <span class="built_in">abort</span>();   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;++++++++++++++++++\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>4.alarm 函数(闹钟)</strong></p>
<p>#include &lt;unistd.h&gt;</p>
<p> unsigned int alarm(unsigned int seconds);</p>
<p>功能：</p>
<p>设置定时器(闹钟)。 在指定 seconds 后， 内核会给当前进程发送 14） SIGALRM 信号。 进程收到该信号， 默认动作终止。 每个进程都有且只有唯一的一个定时器。</p>
<p>取消定时器 alarm(0)， 返回旧闹钟余下秒数。</p>
<p>参数：</p>
<p>seconds： 指定的时间， 以秒为单位</p>
<p>返回值：</p>
<p>返回 0 或剩余的秒数</p>
<p>案例</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时5秒钟\n&quot;</span>);    <span class="comment">// 第一次定时alarm返回0  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret = alarm(<span class="number">5</span>); <span class="comment">///&lt;  不阻塞   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);  </span><br><span class="line">    sleep(<span class="number">2</span>);   </span><br><span class="line">    ret = alarm(<span class="number">10</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);  </span><br><span class="line">    getchar();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107190629356.png"
                      alt="image-20240107190629356"
                ></p>
<p>定时， 与进程状态无关(自然定时法)！ 就绪、 运行、 挂起(阻塞、 暂停)、 终止、 僵尸……无论进程处于何种状态， alarm 都计时。</p>
<p>5.setitimer 函数（定时器）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 闹钟触发周期 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span> <span class="comment">// 闹钟触发时间 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">// 秒  </span></span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125; itimerval.it_value： 设定第一次执行 function 所延迟的秒数 </span><br><span class="line">    itimerval.it_interval： 设定以后每几秒执行 function</span><br></pre></td></tr></table></figure></div>

<p>功能：</p>
<p>设置定时器(闹钟)。 可代替 alarm 函数。 精度微秒 us， 可以实现周期定时。</p>
<p>参数：</p>
<p>which： 指定定时方式</p>
<p>a) 自然定时： ITIMER_REAL → 14） SIGALRM 计算自然时间</p>
<p>b) 虚拟空间计时(用户空间)： ITIMER_VIRTUAL → 26） SIGVTALRM 只计算进程占用 cpu 的时间</p>
<p>c) 运行时计时(用户 + 内核)： ITIMER_PROF → 27） SIGPROF 计算占用 cpu 及执行系统调用的时间</p>
<p>new_value： struct itimerval, 负责设定 timeout 时间</p>
<p>old_value： 存放旧的 timeout 值， 一般指定为 NULL</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： -1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107191043092.png"
                      alt="image-20240107191043092"
                ></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span>    <span class="comment">// 定时周期  </span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">1</span>;  </span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;    <span class="comment">// 第一次触发的时间 </span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">2</span>;  </span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>; </span><br><span class="line">    signal(SIGALRM, myfunc);                  <span class="comment">// 信号处理    </span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 定时器设置   </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        ;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107191153439.png"
                      alt="image-20240107191153439"
                ></p>
<p><strong>5.pause函数</strong></p>
<p>#include &lt;unistd.h&gt;</p>
<p> int pause(void);</p>
<p>功能：</p>
<p>将调用进程挂起直至捕捉到信号为止。这个函数通常用于判断信号是否已到。</p>
<p>返回值：</p>
<p>直到捕获到信号， pause 函数才返回-1，且 errno 被设置成 EINTR。</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line"></span><br><span class="line">&#123;   </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;in pause function\n&quot;</span>);  </span><br><span class="line">	 pause(); </span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.10 给信号注册自定义函数</strong></p>
<p><strong>1.信号的处理方式</strong></p>
<p>1） 执行系统默认动作 对大多数信号来说， 系统默认动作是用来终止该进程。</p>
<p>2） 忽略此信号(丢弃) 接收到此信号后没有任何动作。</p>
<p>3） 执行自定义信号处理函数(捕获) 用用户定义的信号处理函数处理该信号。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107191236763.png"
                      alt="image-20240107191236763"
                ></p>
<p><strong>捕捉信号并且信号信号的处理方式有两个函数,signal 和 sigaction</strong></p>
<p><strong>2.signal注册信号处理函数</strong></p>
<p>#include &lt;signal.h&gt;</p>
<p> typedef void(*sighandler_t)(int); </p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p>功能：</p>
<p>注册信号处理函数（不可用于 SIGKILL、 SIGSTOP 信号） ， 即确定收到信号后处理函数的入口地址。 此函数不会阻塞。</p>
<p>参数：</p>
<p>signum： 信号的编号， 这里可以填数字编号， 也可以填信号的宏定义， 可以通过命令 kill - l(“l” 为字母)进行相应查看。</p>
<p>handler : 取值有 3 种情况：</p>
<p>SIG_IGN： 忽略该信号</p>
<p>SIG_DFL： 执行系统默认动作</p>
<p>信号处理函数名： 自定义信号处理函数. 如： void func(int signo)</p>
<p>回调函数的定义如下：</p>
<p>void func(int signo) { &#x2F;&#x2F; signo 为触发的信号， 为 signal() 第一个参数的值 }</p>
<p>返回值：成功： 第一次返回 NULL， 下一次返回此信号上一次注册的信号处理函数的地址。 如果需要使用此返回值， 必须在前面先声明此函数指针的类型。</p>
<p>失败： 返回 SIG_ERR</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_done</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT)</span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)   </span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        <span class="built_in">free</span>(p);   </span><br><span class="line">        p = <span class="literal">NULL</span>;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p指针已经释放\n&quot;</span>);   </span><br><span class="line">        _exit(<span class="number">0</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 注册CTRL+C的信号处理函数  </span></span><br><span class="line">    signal(SIGINT, my_done);  </span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">16</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p); </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// CTRL+C不会调用free </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.sigaction函数</strong></p>
<p>#include &lt;signal.h&gt; </p>
<p>int sigaction(int signum, const struct sigaction <em>act, struct sigaction</em>oldact);</p>
<p>功能：</p>
<p>检查或修改指定信号的设置（或同时执行这两种操作） 。</p>
<p>参数：</p>
<p>signum： 要操作的信号。</p>
<p>act： 要设置的对信号的新处理方式（传入参数） 。</p>
<p>oldact： 原来对信号的处理方式（传出参数） 。</p>
<p>如果 act 指针非空， 则要改变指定信号的处理方式（设置） ， 如果 oldact 指针非空， 则系统将此前指定信号的处理方式存入 oldact。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： -1</p>
<p>struct sigaction 结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针 </span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//新的信号处理函数指针 </span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask; <span class="comment">//信号阻塞集 </span></span><br><span class="line">    <span class="type">int</span> sa_flags; <span class="comment">//信号处理的方式 </span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>sa_flags： 用于指定信号处理的行为， 通常设置为 0， 表使用默认属性。</p>
<p>它可以是一个值的“按位或”组合：</p>
<p> Ø SA_NOCLDSTOP： 使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</p>
<p> Ø SA_NOCLDWAIT： 使父进程在它的子进程退出时不会收到 SIGCHLD 信号， 这时子进程如果退出也不会成为僵尸进程。</p>
<p> ØSA_NODEFER： 使对信号的屏蔽无效， 即在信号处理函数执行期间仍能发出这个信号。</p>
<p> Ø SA_RESETHAND： 信号处理之后重新设置为默认的处理方式。</p>
<p> ØSA_SIGINFO： 使用 sasigaction 成员而不是 sahandler 作为信号处理函数(默认为旧的信号处理函数指针)。</p>
<p>信号处理函数sa_sigaction:</p>
<p>void(*sa_sigaction)(int signum, siginfo_t *info, void *context); 参数说明： signum： 信号的编号。 info： 记录信号发送进程信息的结构体。 context： 可以赋给指向 ucontext_t 类型的一个对象的指针， 以引用在传递信号时被中断的接收进程或线程的上下文。</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_func</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CTRL+C被按下\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span>     <span class="comment">// 给sa_mask赋值，清空阻塞信号集  </span></span><br><span class="line">    <span class="comment">// sigemptyset(&amp;act.sa_mask);     // 将所有信号添加到阻塞集</span></span><br><span class="line">    <span class="comment">// sigfillset(&amp;act.sa_mask);     // 信号的处理方式   </span></span><br><span class="line">    <span class="comment">// act.sa_flags = 0;   </span></span><br><span class="line">    act.sa_flags |= SA_RESETHAND;    <span class="comment">// 设置信号处理函数    </span></span><br><span class="line">    act.sa_handler = my_func;     <span class="comment">// 注册CTRL+C信号处理函数  </span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">        ;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.11信号集</strong></p>
<p><strong>1.信号集的概述</strong></p>
<p>在 PCB 中有两个非常重要的信号集。 一个称之为“阻塞信号集”， 另一个称之为“未决信号集”。 这两个信号集都是内核使用位图机制来实现的。 但操作系统不允许我们直接对其进行位操作。 而需自定义另外一个集合， 借助信号集操作函数来对 PCB中的这两个信号集进行修改。</p>
<p><strong>2.信号集的处理函数</strong></p>
<p>信号集的类型：sigset_t</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">//将 set 集合置空 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>； <span class="comment">//将所有信号加入 set 集合 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//将 signo 信号加入到 set 集合 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//从 set 集合中移除 signo 信号 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure></div>

<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 700</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 定义一个信号集   </span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;    </span><br><span class="line">    <span class="comment">//清空信号集 </span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);   </span><br><span class="line">    <span class="comment">//添加SIGINT到信号集 </span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT); </span><br><span class="line">    <span class="comment">//添加SIGPIPE到信号集  </span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGPIPE);  </span><br><span class="line">    <span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>, SIGINT))  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 在信号集中\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不在信号集中\n&quot;</span>); </span><br><span class="line">    <span class="comment">//将SIGINT信号从信号集中移除  </span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGINT); </span><br><span class="line">    <span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>, SIGINT))     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 在信号集中\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不在信号集中\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>13.12 阻塞信号集</strong></p>
<p><strong>1.阻塞信号集的概述</strong></p>
<p>信号阻塞集也称信号屏蔽集、 信号掩码。 每个进程都有一个阻塞集， 创建子进程时子进程将继承父进程的阻塞集。 信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它， 直到进程准备好时再将信号通知进程） 。 所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。 若将被阻塞的信号从信号阻塞集中删除， 且对应的信号在被阻塞时发生了， 进程将会收到相应的信号。</p>
<p><strong>2.阻塞信号集的API</strong></p>
<p><strong>2.1 sigprocmask函数</strong></p>
<p>#include &lt;signal.h&gt; </p>
<p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</p>
<p>功能：</p>
<p>检查或修改信号阻塞集， 根据 how 指定的方法对进程的阻塞集合进行修改， 新的信号阻塞集由 set 指定， 而原先的信号阻塞集合由 oldset 保存。</p>
<p>参数：</p>
<p>how : 信号阻塞集合的修改方法， 有 3 种情况：</p>
<p>SIG_BLOCK： 向信号阻塞集合中添加 set 信号集， 新的信号掩码是 set 和旧信号掩码的并集。 相当于 mask &#x3D; mask|set。</p>
<p>SIG_UNBLOCK： 从信号阻塞集合中删除 set 信号集， 从当前信号掩码中去除 set 中的信号。 相当于 mask &#x3D; mask &amp; ~ set。SIG_SETMASK： 将信号阻塞集合设为 set 信号集， 相当于原来信号阻塞集的内容清空， 然后按照 set 中的信号重新设置信号阻塞集。 相当于 mask &#x3D; set。</p>
<p>set : 要操作的信号集地址。</p>
<p>若 set 为 NULL， 则不改变信号阻塞集合， 函数只把当前信号阻塞集合保存到oldset 中。</p>
<p>oldset : 保存原先信号阻塞集地址</p>
<p>返回值：</p>
<p>成功： 0，</p>
<p>失败： -1， 失败时错误代码只可能是 EINVAL， 表示参数 how 不合法。</p>
<p><strong>2.2sigpending函数</strong></p>
<p>#include &lt;signal.h&gt; </p>
<p> int sigpending(sigset_t *set);</p>
<p>功能： 读取当前进程的未决信号集</p>
<p>参数：</p>
<p>set： 未决信号集</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： -1</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 700</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;   </span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>); </span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);   </span><br><span class="line">    <span class="comment">// 将set集合添加到信号阻塞集 </span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGINT信号5秒后从阻塞集中删除\n&quot;</span>); </span><br><span class="line">    sleep(<span class="number">5</span>);    </span><br><span class="line">    <span class="comment">// 将set集合从信号阻塞集移除  </span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;    </span><br><span class="line">        ;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【14】进程间通信总结</strong></p>
<p><strong>1.进程间通讯的方式</strong></p>
<p>共七种：</p>
<p>同一主机之间：无名管道、有名管道、消息队列、磁盘映射、内存映射、信号。</p>
<p>不同主机之间：socket套接字（网络通信）</p>
<p><strong>2.每种通讯方式的特点</strong></p>
<p>无名管道：有血缘关系、半双工、一对一、先进先出、无格式、数据读取一次性、内存中。</p>
<p>有名管道：无血缘关系、半双工、一对一、先进先出、无格式、数据读取一次性、内存映射的磁盘文件。</p>
<p>消息队列：多对多、按类型读取、有格式、数据读取一次性、内存中、类型不同的消息支持随机读取、类型的消息先进先出。</p>
<p>mmap磁盘映射：多对多、无格式，数据读取后还存在，写入时覆盖原文件，磁盘中。</p>
<p>内存映射：多对多、无格式、数据读取后还存在，写入时覆盖原文件、物理内存中。</p>
<p>信号：简单、不能携带大量数据、满足条件发出信号。</p>
<p>socket套接字：不同主机之间。</p>
<p><strong>知识点【15】linux 多任务编程之线程</strong></p>
<p><strong>15.1进程与线程的关系</strong></p>
<p>进程是系统分配资源的基本单位，线程是cpu执行的基本单位，每个进程必须要有一个线程（主线程），linux下进程与线程的概念是比较模糊的，线程依赖于进程（资源来源于进程）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107192342731.png"
                      alt="image-20240107192342731"
                ></p>
<p>进程所有的线程都是共享进程资源，如果进程结束，那么该进程的所有线程都将结束，线程具有独立的栈，它本身就是一个函数体，</p>
<p>查看指定进程的LWP：ps -Lf pid</p>
<p>线程函数列表安装: sudo apt-get install manpages-posix-dev</p>
<p>【说明】 manpages-posix-dev 包含 POSIX 的 header files 和 library calls 的用法</p>
<p>查看：man -k pthread</p>
<p>线程所有操作函数 pthread* 是库函数， 而非系统调用，使用线程是需要引入头文件, 编译时要加上 -lpthread</p>
<p><strong>15.2线程的共享资源</strong></p>
<ol>
<li><p>文件描述符表 </p>
</li>
<li><p>每种信号的处理方式</p>
</li>
<li><p>当前工作目录</p>
</li>
<li><p>用户 ID 和组 ID内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</p>
</li>
</ol>
<p><strong>15.3线程的非共享资源</strong></p>
<ol>
<li><p>线程 id </p>
</li>
<li><p>处理器现场和栈指针(内核栈) </p>
</li>
<li><p>独立的栈空间(用户空间栈)</p>
</li>
</ol>
<p>4)errno 变量 </p>
<ol start="5">
<li><p>信号屏蔽字</p>
</li>
<li><p>调度优先级</p>
</li>
</ol>
<p><strong>15.4线程的优缺点</strong></p>
<p>优点： Ø 提高程序并发性 Ø 开销小 Ø 数据通信、 共享数据方便</p>
<p>缺点： Ø 库函数， 不稳定 Ø 调试、 编写困难、 gdb 不支持 Ø 对信号支持不好 优点相对突出， 缺点均不是硬伤。</p>
<p>Linux 下由于实现方法导致进程、 线程差别不是很大。</p>
<p><strong>知识点【16】线程创建</strong></p>
<p><strong>16.1 线程号(pthread_t)</strong></p>
<p>只在所属进程环境中有效且唯一。</p>
<p>linux系统中使用无符号长整形表示。</p>
<p><strong>16.2 获取线程号</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> pthread_t pthread_self(void);</p>
<p>功能：</p>
<p>获取线程号。</p>
<p>参数：</p>
<p>无</p>
<p>返回值：</p>
<p>调用线程的线程 ID 。</p>
<p><strong>16.3 创建线程</strong></p>
<p>为了执行多任务。</p>
<p>#include &lt;pthread.h&gt; </p>
<p>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg );</p>
<p>功能：</p>
<p>创建一个线程</p>
<p>参数：</p>
<p>thread：线程标识符地址。</p>
<p>attr： 线程属性结构体地址， 通常设置为 NULL。</p>
<p>start_routine： 线程函数的入口地址。</p>
<p>arg： 传给线程函数的参数。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>   </span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];    </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; <span class="type">student_t</span>, *<span class="type">pstudent_t</span>; </span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func1</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pstudent_t</span> stu = (<span class="type">pstudent_t</span>)arg; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程1:%lu, name = %s:%d\n&quot;</span>, pthread_self(), stu-&gt;name, stu-&gt;age); </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func2</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pstudent_t</span> stu = (<span class="type">pstudent_t</span>)arg;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2:%lu, name = %s:%d\n&quot;</span>, pthread_self(), stu-&gt;name, stu-&gt;age);  </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> iret = <span class="number">-1</span>; </span><br><span class="line">    <span class="type">pstudent_t</span> stu1; </span><br><span class="line">    <span class="type">pstudent_t</span> stu2;  </span><br><span class="line">    <span class="type">pthread_t</span> tid1; </span><br><span class="line">    <span class="type">pthread_t</span> tid2;  </span><br><span class="line">    stu1 = (<span class="type">pstudent_t</span>)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">student_t</span>)); </span><br><span class="line">    stu1-&gt;age = <span class="number">20</span>; </span><br><span class="line">    <span class="built_in">strcpy</span>(stu1-&gt;name, <span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">    iret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, my_func1, (<span class="type">void</span> *)stu1);  </span><br><span class="line">    <span class="keyword">if</span> (iret &lt; <span class="number">0</span>)   </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;pthread_create1&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    stu2 = (<span class="type">pstudent_t</span>)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">student_t</span>));   </span><br><span class="line">    stu2-&gt;age = <span class="number">19</span>;   </span><br><span class="line">    <span class="built_in">strcpy</span>(stu2-&gt;name, <span class="string">&quot;bob&quot;</span>);  </span><br><span class="line">    iret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, my_func2, (<span class="type">void</span> *)stu2);  </span><br><span class="line">    <span class="keyword">if</span> (iret &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;    </span><br><span class="line">        perror(<span class="string">&quot;pthread_create2&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;     </span><br><span class="line">    pause();</span><br><span class="line">    <span class="built_in">free</span>(stu1); </span><br><span class="line">    stu1 = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="built_in">free</span>(stu2);  </span><br><span class="line">    stu2 = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程已结束\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Makefile:</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc:=gcc</span><br><span class="line">cflags:= -lpthread </span><br><span class="line">all:=my_func</span><br><span class="line"><span class="section">$&#123;all&#125;:$&#123;src&#125;  </span></span><br><span class="line">	$&#123;cc&#125; -o <span class="variable">$@</span> <span class="variable">$^</span> $&#123;cflags&#125; </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f $&#123;all&#125; *.o</span><br></pre></td></tr></table></figure></div>

<p>编译命令：make src&#x3D;xxx.c</p>
<p><strong>16.4 线程资源回收</strong></p>
<p>pthread_join 函数：</p>
<p>#include &lt;pthread.h&gt; </p>
<p>int pthread_join(pthread_t thread, void **retval);</p>
<p>功能：</p>
<p>等待线程结束（此函数会阻塞） ， 并回收线程资源， 类似进程的 wait() 函数。 如果线程已经结束， 那么该函数会立即返回。</p>
<p>参数：</p>
<p>thread： 被等待的线程号。</p>
<p>retval： 用来存储线程退出状态的指针的地址，一般情况下都使用NULL。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;  </span><br><span class="line">    sleep(<span class="number">7</span>);  </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="string">&quot;线程A&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;   </span><br><span class="line">    sleep(<span class="number">3</span>); </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="string">&quot;线程B&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, my_func1, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, my_func2, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="type">void</span> *p1 = <span class="literal">NULL</span>;    <span class="type">void</span> *p2 = <span class="literal">NULL</span>;     <span class="comment">// 回收线程资源 </span></span><br><span class="line">    pthread_join(tid1, &amp;p1); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1 = %s\n&quot;</span>, (<span class="type">char</span> *)p1);  </span><br><span class="line">    pthread_join(tid2, &amp;p2);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 = %s\n&quot;</span>, (<span class="type">char</span> *)p2); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>16.5线程分离（pthread_detach）</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_detach(pthread_t thread);</p>
<p>功能：</p>
<p>使调用线程与当前进程分离， 分离后不代表此线程不依赖与当前进程， 线程分离的目的是将线程资源的回收工作交由系统自动来完成， 也就是说当被分离的线程结束之后， 系统会自动回收它的资源。 所以， 此函数不会阻塞.</p>
<p>参数：</p>
<p>thread： 线程号。</p>
<p>返回值:</p>
<p>成功： 0</p>
<p>失败： 非 0</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程1:%lu, i = %d, arg = %s\n&quot;</span>, pthread_self(), i, (<span class="type">char</span> *)arg); </span><br><span class="line">        i++;     </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>)     </span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">pthread_t</span> tid; </span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, my_func, <span class="string">&quot;hello thread&quot;</span>);     <span class="comment">// 设置线程分离  </span></span><br><span class="line">    pthread_detach(tid); <span class="comment">//不能在调用pthread_join函数   </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)      </span><br><span class="line">        ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【17】线程的退出与取消</strong></p>
<p><strong>17.1 线程退出</strong></p>
<p>#include &lt;pthread.h&gt; </p>
<p>void pthread_exit(void *retval);</p>
<p>功能：</p>
<p>退出调用线程。 一个进程中的多个线程是共享该进程的数据段， 因此， 通常线程退出后所占用的资源并不会释放。</p>
<p>参数：</p>
<p>retval： 存储线程退出状态的指针。</p>
<p>返回值： 无</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu:i = %d\n&quot;</span>, pthread_self(), i++);  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>)  </span><br><span class="line">        &#123;          </span><br><span class="line">            <span class="comment">//线程退出         </span></span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);   </span><br><span class="line">        &#125;     </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pthread_t</span> tid;   </span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, my_func, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数已退出\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>17.2线程取消</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_cancel(pthread_t thread);</p>
<p>功能：</p>
<p>杀死(取消)线程</p>
<p>参数：</p>
<p>thread : 目标线程 ID。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 出错编号</p>
<p>注意： 线程的取消并不是实时的， 而又一定的延时。 需要等待线程到达某个取消点(检查点)。</p>
<p>取消点： 是线程检查是否被取消， 并按请求进行动作的一个位置。</p>
<p>通常是一些系统调用 creat， open， pause， close， read， write….. 执行命令 man 7 pthreads 可以查看具备这些取消点的系统调用列表。</p>
<p> 可粗略认为一个系统调用(进入内核)即为一个取消点。</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu:i = %d\n&quot;</span>, pthread_self(), i++);</span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pthread_t</span> tid; </span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, my_func, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程5秒后退出\n&quot;</span>);  </span><br><span class="line">    sleep(<span class="number">5</span>);   </span><br><span class="line">    <span class="comment">//取消指定线程  </span></span><br><span class="line">    pthread_cancel(tid); </span><br><span class="line">    sleep(<span class="number">1</span>);  </span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主函数已退出\n&quot;</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【18】线程属性</strong></p>
<p><strong>1.线程属性概述</strong></p>
<p>Linux 下线程的属性是可以根据实际项目需要， 进行设置， 之前我们讨论的线程都是采用线程的默认属性， 默认属性已经可以解决绝大多数开发时遇到的问题。 如我们对程序的性能提出更高的要求那么需要设置线程属性， 比如可以通过设置线程栈的大小来降低内存的使用， 增加最大线程个数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>   </span><br><span class="line">    <span class="type">int</span> etachstate; <span class="comment">//线程的分离状态 </span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">//线程的继承性   </span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">//线程的作用域    </span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小   </span></span><br><span class="line">    <span class="type">int</span> stackaddr_set; <span class="comment">//线程的栈设置 </span></span><br><span class="line">    <span class="type">void</span>* stackaddr; <span class="comment">//线程栈的位置    </span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.主要成员介绍</strong></p>
<p>\1. 线程分离状态</p>
<p>\2. 线程栈大小（默认平均分配）</p>
<p>\3. 线程栈警戒缓冲区大小（位于栈末尾）</p>
<p>\4. 线程栈最低地址 属性值不能直接设置，须使用相关函数进行操作， 初始化的函数为 pthread_attr_init， 这个函数必须在pthread_create 函数之前调用。 之后须用 pthreadattr_destroy 函数来释放资源。</p>
<p>线程属性主要包括如下属性： 作用域（scope） 、 栈尺寸（stack size） 、 栈地址（stack address） 、 优先级（priority） 、 分离的状态（detached state） 、 调度策略和参数（scheduling policy and parameters） 。 默认的属性为非绑定、 非分离、缺省的堆栈、 与父进程同样级别的优先级。</p>
<p><strong>3.线程属性初始化及销毁</strong></p>
<p>初始化线程属性函数：</p>
<p>int pthread_attr_init(pthreadattrt *attr); 函数返回值：     成功： 0；     失败： 错误号 </p>
<p>销毁线程属性所占用的资源函数:</p>
<p>int pthread_attr_destroy(pthreadattrt *attr);  函数返回值： 成功： 0； 失败： 错误号</p>
<p><strong>4.通过线程属性实现线程分离</strong></p>
<p>线程设置分离状态  分离or 非分离：</p>
<p>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);  </p>
<p>参数：    </p>
<p> attr： 已初始化的线程属性   </p>
<p> detachstate： 分离状态       </p>
<p> PTHREAD_CREATE_DETACHED（分离线程）         </p>
<p>PTHREAD_CREATE_JOINABLE（非分离线程）</p>
<p>获取线程属性， 分离or 非分离：</p>
<p>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstat);  </p>
<p>参数：  </p>
<p>  attr： 已初始化的线程属性 </p>
<p> detachstate： 分离状态</p>
<p>案例：设置线程分离属性</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu:i = %d\n&quot;</span>, pthread_self(), i++);  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>)   </span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        sleep(<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pthread_t</span> tid;   </span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;    </span><br><span class="line">    <span class="comment">// 初始化线程属性  </span></span><br><span class="line">    pthread_attr_init(&amp;attr);    </span><br><span class="line">    <span class="comment">// 设置线程为分离状态  </span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); </span><br><span class="line">    pthread_create(&amp;tid, &amp;attr, my_func, <span class="literal">NULL</span>);</span><br><span class="line">    getchar(); </span><br><span class="line">    <span class="comment">// 销毁线程属性  </span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>5.通过线程属性设置线程栈空间</strong></p>
<p>当进程栈地址空间不够用时， 指定新建线程使用由 malloc 分配的空间作为自己的栈空间。 通过 pthread_attrs_etstack 和pthread_attrg_etstack 两个函数分别设置和获取线程的栈地址。</p>
<p>设置线程栈地址：</p>
<p>int pthreadattrsetstack(pthread_attr_t *attr, void *stackaddr, sizet stacksize); 成功：  0；  失败： 错误号</p>
<p>获取线程栈地址：</p>
<p>int pthread_attr_getstack(pthreadattrt *attr, void *<em>stackaddr, sizet</em>stacksize);  成功： 0； 失败： 错误号 </p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)   </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu:i = %d\n&quot;</span>, pthread_self(), i++);  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>)     </span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pthread_t</span> tid; </span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;  </span><br><span class="line">    <span class="comment">// 初始化线程属性 </span></span><br><span class="line">    pthread_attr_init(&amp;attr); </span><br><span class="line">    <span class="comment">// 设置线程为分离状态   </span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); </span><br><span class="line">    <span class="comment">// 堆区申请空间 </span></span><br><span class="line">    <span class="type">void</span> *stackaddr = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">128</span>);  </span><br><span class="line">    <span class="keyword">if</span> (stackaddr == <span class="literal">NULL</span>)  </span><br><span class="line">    &#123;      </span><br><span class="line">        perror(<span class="string">&quot;calloc&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 设置线程栈空间为堆区空间  </span></span><br><span class="line">    pthread_attr_setstack(&amp;attr, stackaddr, <span class="number">128</span>);</span><br><span class="line">    pthread_create(&amp;tid, &amp;attr, my_func, <span class="literal">NULL</span>);  </span><br><span class="line">    getchar();     </span><br><span class="line">    <span class="comment">// 销毁线程属性  </span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);    </span><br><span class="line">    <span class="built_in">free</span>(stackaddr);   </span><br><span class="line">    stackaddr = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>知识点【19】线程的同步与互斥</strong></p>
<p>互斥：同一时间只有一个任务执行（进程或线程），执行顺序不确定。</p>
<p>同步：同一时间只有一个任务执行， 执行顺序是确定的。</p>
<p><strong>19.1互斥锁</strong></p>
<p><strong>1.互斥锁概述</strong></p>
<p>用于线程间的互斥，一种简单的加锁的方法来控制对共享资源的访问， 互斥锁只有两种状态,即加锁( lock )和解锁( unlock )。</p>
<p><strong>2.互斥锁操作流程</strong></p>
<p>1） 在访问共享资源或临界区域前， 对互斥锁进行加锁。 </p>
<p>2） 在访问完成后释放互斥锁就是对互斥锁进行解锁锁。</p>
<p>3） 对互斥锁进行加锁后， 任何其他试图再次对互斥锁加锁的线程将会被阻塞， 直到锁被释放。</p>
<p>互斥锁的数据类型是： pthread_mutex_t</p>
<p><strong>3.互斥锁的相关API</strong></p>
<p><strong>3.1互斥锁的初始化</strong></p>
<p>pthread_mutex_init 函数：</p>
<p>#include &lt;pthread.h&gt; </p>
<p>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);</p>
<p>功能：</p>
<p>初始化一个互斥锁。</p>
<p>参数：</p>
<p>mutex： 互斥锁地址。 类型是 pthread_mutex_t 。</p>
<p>attr： 设置互斥量的属性， 通常可采用默认属性， 即可将 attr 设为 NULL。</p>
<p>返回值：</p>
<p>成功： 0， 成功申请的锁默认是打开的。</p>
<p>失败： 非 0 错误码</p>
<p>可以使用宏 PTHREAD_MUTEX_INITIALIZER 静态初始化互斥锁， 比如：pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;</p>
<p>这种方法等价于使用 NULL 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进行错误检查。</p>
<p><strong>3.2销毁互斥锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_mutex_destroy(pthread_mutex_t *mutex);</p>
<p>功能：</p>
<p>销毁指定的一个互斥锁。 互斥锁在使用完毕后， 必须要对互斥锁进行销毁， 以释放资源。</p>
<p>参数：</p>
<p>mutex： 互斥锁地址。</p>
<p>返回值:</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p><strong>3.3 申请上锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_mutex_lock(pthread_mutex_t *mutex);</p>
<p>功能：</p>
<p>对互斥锁上锁， 若互斥锁已经上锁， 则调用者阻塞， 直到互斥锁解锁后再上锁。</p>
<p>参数：</p>
<p>mutex： 互斥锁地址。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p><strong>尝试上锁（非阻塞）</strong></p>
<p>int pthread_mutex_trylock(pthread_mutex_t *mutex);</p>
<p>调用该函数时， 若互斥锁未加锁， 则上锁， 返回 0；</p>
<p>若互斥锁已加锁， 则函数直接返回失败， 即 EBUSY。</p>
<p><strong>3.4 解锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<p>功能：</p>
<p>对指定的互斥锁解锁。</p>
<p>参数：</p>
<p>mutex： 互斥锁地址。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 定义一个互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);   </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">        usleep(<span class="number">500</span> * <span class="number">1000</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func1</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 申请上锁   </span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);    </span><br><span class="line">    print_string(arg);    </span><br><span class="line">    <span class="comment">// 解锁  </span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func2</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 申请上锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex); </span><br><span class="line">    print_string(arg);  </span><br><span class="line">    <span class="comment">// 解锁   </span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2; </span><br><span class="line">    <span class="comment">// 初始化互斥锁  </span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, my_func1, <span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, my_func2, <span class="string">&quot;hello china&quot;</span>); </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="comment">// 销毁互斥锁   </span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>19.2 死锁</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107204726058.png"
                      alt="image-20240107204726058"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107204741651.png"
                      alt="image-20240107204741651"
                ></p>
<p>上锁之后，假如出现问题不得不退出该线程，注意记得解锁后退出。</p>
<p><strong>19.3读写锁</strong></p>
<p><strong>1.读写锁的概述</strong></p>
<p>读操作不会对共享资源产生影响。</p>
<p>在对数据的读写操作中， 更多的是读操作， 写操作较少， 例如对数据库数据的读写应用。 为了满足当前能够允许多个读出， 但只允许一个写入的需求， 线程提供了读写锁来实现。</p>
<p>多个读操作，多个写操作时考虑使用读写锁。</p>
<p>单个读、单个写时用互斥锁即可。</p>
<p>读写锁的数据类型是： pthread_rwlock_t</p>
<p><strong>2.读写锁的特点及规则</strong></p>
<p><strong>读写锁的特点如下：</strong></p>
<p> 1） 如果有其它线程读数据， 则允许其它线程执行读操作，但不允许写操作。</p>
<p> 2） 如果有其它线程写数据， 则其它线程都不允许读、 写操作。</p>
<p><strong>读写锁分为读锁和写锁， 规则如下：</strong></p>
<p> 1） 如果某线程申请了读锁， 其它线程可以再申请读锁， 但不能申请写锁。</p>
<p> 2） 如果某线程申请了写锁， 其它线程不能申请读锁， 也不能申请写锁。</p>
<p><strong>3.读写锁的API</strong></p>
<p><strong>3.1 读写锁的初始化</strong></p>
<p>#include &lt;pthread.h&gt; </p>
<p>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);</p>
<p>功能：</p>
<p>用来初始化 rwlock 所指向的读写锁。</p>
<p>参数：</p>
<p>rwlock： 指向要初始化的读写锁指针。</p>
<p>attr： 读写锁的属性指针。 如果 attr 为 NULL 则会使用默认的属性初始化读写锁， 否则使用指定的 attr 初始化读写锁。</p>
<p>可以使用宏 PTHREAD_RWLOCK_INITIALIZER 静态初始化读写锁， 比如：pthread_rwlock_t my_rwlock &#x3D; PTHREAD_RWLOCK_INITIALIZER;</p>
<p>这种方法等价于使用 NULL 指定的 attr 参数调用 pthread_rwlock_init() 来完成动态初始化， 不同之处在于 PTHREAD_RWLOCK_INITIALIZER 宏不进行错误检查。</p>
<p>返回值：</p>
<p>成功： 0， 读写锁的状态将成为已初始化和已解锁。</p>
<p>失败： 非 0 错误码。</p>
<p><strong>3.2申请读锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p>
<p>功能：</p>
<p>以阻塞方式在读写锁上获取读锁（读锁定） 。</p>
<p>如果没有写者持有该锁， 并且没有写者阻塞在该锁上， 则调用线程会获取读锁。</p>
<p>如果调用线程未获取读锁， 则它将阻塞直到它获取了该锁。 一个线程可以在一个读写锁上多次执行读锁定。</p>
<p>线程可以成功调用 pthread_rwlock_rdlock() 函数 n 次， 但是之后该线程必须调用 pthread_rwlock_unlock() 函数 n 次才能解除锁定。</p>
<p>参数：</p>
<p>rwlock： 读写锁指针。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</p>
<p>用于尝试以非阻塞的方式来在读写锁上获取读锁。</p>
<p>如果有任何的写者持有该锁或有写者阻塞在该读写锁上， 则立即失败返回。</p>
<p><strong>3.3申请写锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p>
<p>功能：</p>
<p>在读写锁上获取写锁（写锁定） 。</p>
<p>如果没有写者持有该锁， 并且没有写者读者持有该锁， 则调用线程会获取写锁。</p>
<p>如果调用线程未获取写锁， 则它将阻塞直到它获取了该锁。</p>
<p>参数：</p>
<p>rwlock： 读写锁指针。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</p>
<p>用于尝试以非阻塞的方式来在读写锁上获取写锁。</p>
<p>如果有任何的读者或写者持有该锁， 则立即失败返回。</p>
<p><strong>3.4解锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</p>
<p>功能：</p>
<p>无论是读锁或写锁， 都可以通过此函数解锁。</p>
<p>参数：</p>
<p>rwlock： 读写锁指针。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p><strong>3.5释放读写锁</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p>
<p>功能：</p>
<p>用于销毁一个读写锁， 并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init() 自动申请的资源 。</p>
<p>参数：</p>
<p>rwlock： 读写锁指针。</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误码</p>
<p>案例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_rdfunc1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务A中的num = %d\n&quot;</span>, num);  </span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);   </span><br><span class="line">        sleep(<span class="number">3</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_rdfunc2</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;       </span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务B中的num = %d\n&quot;</span>, num);  </span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock); </span><br><span class="line">        sleep(<span class="number">3</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_wrfunc1</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;     </span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务C中的num = %d\n&quot;</span>, num);   </span><br><span class="line">        num++;    </span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock); </span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pthread_t</span> tid1_r, tid2_r, tid3_w;  </span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_create(&amp;tid1_r, <span class="literal">NULL</span>, my_rdfunc1, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_create(&amp;tid2_r, <span class="literal">NULL</span>, my_rdfunc2, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_create(&amp;tid3_w, <span class="literal">NULL</span>, my_wrfunc1, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_join(tid1_r, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_join(tid2_r, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_join(tid3_w, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>19.4条件变量</strong></p>
<p><strong>1.条件变量概述</strong></p>
<p>条件变量在使用时一般与互斥锁联合使用。</p>
<p>与互斥锁不同， 条件变量是用来等待而不是用来上锁的， 条件变量本身不是锁！条件变量用来自动阻塞一个线程， 直到某特殊情况发生为止。 通常条件变量和互斥锁同时使用。 条件变量的两个动作： 条件不满, 阻塞线程 当条件满足, 通知阻塞的线程开始工作。</p>
<p>条件变量的类型: pthread_cond_t。</p>
<p><strong>2.条件变量的API</strong></p>
<p><strong>2.1 条件变量初始化</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</p>
<p>功能：</p>
<p>初始化一个条件变量</p>
<p>参数：</p>
<p>cond： 指向要初始化的条件变量指针。</p>
<p>attr： 条件变量属性， 通常为默认值， 传 NULL 即可</p>
<p>也可以使用静态初始化的方法， 初始化条件变量：pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误号</p>
<p><strong>2.2释放条件变量</strong></p>
<p>#include &lt;pthread.h&gt; </p>
<p>int pthread_cond_destroy(pthread_cond_t *cond);</p>
<p>功能：</p>
<p>销毁一个条件变量</p>
<p>参数：</p>
<p>cond： 指向要初始化的条件变量指针</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误号</p>
<p><strong>2.3 等待条件满足（会阻塞）</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</p>
<p>功能：</p>
<p>阻塞等待一个条件变量</p>
<p>a) 阻塞等待条件变量 cond（参 1） 满足</p>
<p>b) 释放已掌握的互斥锁（解锁互斥量） 相当于 pthread_mutex_unlock(&amp;mutex);</p>
<p>a) b) 两步为一个原子操作。</p>
<p>c) 当被唤醒， pthread_cond_wait 函数返回时， 解除阻塞并重新申请获取互斥锁 pthread_mutex_lock(&amp;mutex);</p>
<p>参数：</p>
<p>cond： 指向要初始化的条件变量指针</p>
<p>mutex： 互斥锁</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： 非 0 错误号</p>
<p><strong>限时等待</strong></p>
<p>int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex, \</p>
<p>const struct timespec *restrict abstime);</p>
<p>功能：</p>
<p>​    限时等待一个条件变量</p>
<p>参数：</p>
<p>​    cond： 指向要初始化的条件变量指针</p>
<p>​    mutex： 互斥锁</p>
<p>​    abstime： 绝对时间</p>
<p>返回值：</p>
<p>​    成功： 0</p>
<p>​    失败： 非 0 错误号</p>
<p><strong>2.4唤醒等待在条件变量上的线程</strong></p>
<p>#include &lt;pthread.h&gt;</p>
<p> int pthread_cond_signal(pthread_cond_t *cond);</p>
<p>功能：</p>
<p>唤醒至少一个阻塞在条件变量上的线程</p>
<p>参数</p>
<p>cond： 指向要初始化的条件变量指</p>
<p>返回值</p>
<p>成功： 0</p>
<p>失败： 非 0 错误号</p>
<p>int pthread_cond_broadcast(pthread_cond_t *cond);</p>
<p>功能：</p>
<p>​    唤醒全部阻塞在条件变量上的线程</p>
<p>参数：</p>
<p>​    cond： 指向要初始化的条件变量指针</p>
<p>返回值：</p>
<p>​    成功： 0</p>
<p>​    失败： 非 0 错误号</p>
<p><strong>3.条件变量的工作原理</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107205719871.png"
                      alt="image-20240107205719871"
                ></p>
<p><strong>4.条件变量案例：生成者与消费者（一个生产者，两个消费者）</strong></p>
<p>一个仓库开始有3个产品，</p>
<p>如果生产者生产后放入仓库存放产品，消费者不能进入仓库购买。</p>
<p>如果消费者进入仓库购买产品，生产者不能进入仓库存放物品。</p>
<p>如果仓库商品为0，消费者不能进入仓库。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107205939722.png"
                      alt="image-20240107205939722"
                ></p>
<p><strong>19.5 信号量</strong></p>
<p><strong>1.信号量概述</strong></p>
<p>信号量广泛用于进程或线程间的同步和互斥,信号量本质上是一个非负的整数计数器(根据操作信号量值的结果判断是否对公共资源具有访问的权限),信号量的值大于0，解阻塞，等于0阻塞，不能用if语句判断（因为if语句不是阻塞的），对信号量的操作用的是PV原语，P是减一，V加一，流程永远是先P后V。</p>
<p>信号量类型:sem_t</p>
<p><strong>2.信号量互斥操作（不区分进程还是线程）</strong></p>
<p>不管多少个任务，只需一个信号量，并初始化为1。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107210054413.png"
                      alt="image-20240107210054413"
                ></p>
<p><strong>3.信号量同步操作</strong></p>
<p>顺序执行</p>
<ul>
<li>有多少个任务就要创建多少个信号量。</li>
<li>谁先执行其信号量的初始值为1，其他都为0。</li>
<li>所有任务都是P自己的信号量，V下一个任务的信号量。</li>
</ul>
<p>​    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../imgs/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20240107210110473.png"
                      alt="image-20240107210110473"
                ></p>
<p>注意：进程的信号量与线程的信号量是不一样，单纯信号量用于线程，无名信号量用于有血缘关系的进程，有名信号量用于无血缘关系的信号量。</p>
<p><strong>4.信号量的API（线程的）</strong></p>
<p><strong>4.1 初始化信号量：</strong></p>
<p>#include &lt;semaphore.h&gt;</p>
<p> int sem_init(sem_t *sem, int pshared, unsigned int value)；</p>
<p>功能：</p>
<p>创建一个信号量并初始化它的值。 一个无名信号量在被使用前必须先初始化。</p>
<p>参数：</p>
<p>sem： 信号量的地址</p>
<p>pshared： 等于 0， 信号量在线程间共享（常用） ； 不等于 0， 信号量在进程间共享。</p>
<p>value： 信号量的初始值</p>
<p>返回值：</p>
<p>成功： 0</p>
<p>失败： - 1</p>
<p><strong>4.2 P操作  信号量-1</strong></p>
<p>int sem_wait(sem_t *sem);</p>
<p>功能: 将信号量减一,如果信号量的值为 0 则阻塞,大于 0 可以减一</p>
<p>参数:信号量的地址</p>
<p>返回值:成功返回 0 失败返回-1</p>
<p><strong>尝试对信号量减一：</strong></p>
<p>int sem_trywait(sem_t *sem);</p>
<p>功能: 尝试将信号量减一,如果信号量的值为 0 不阻塞,立即返回 ,大于 0 可以减一</p>
<p>参数:信号量的地址</p>
<p>返回值:成功返回 0 失败返回-1</p>
<p><strong>4.3 V操作 信号量加1</strong></p>
<p>int sem_post(sem_t *sem);</p>
<p>功能:将信号量加一</p>
<p>参数:信号量的地址</p>
<p>返回值:成功返回 0 失败返回-1</p>
<p><strong>4.4销毁信号量</strong></p>
<p>int sem_destroy(sem_t *sem);</p>
<p>功能: 销毁信号量</p>
<p>参数: 信号量的地址</p>
<p>返回值:成功返回 0 失败返回-1</p>
<p>案例：信号量同步案例</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">sem_t</span> sem1, sem2; </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]); </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        usleep(<span class="number">500</span> * <span class="number">1000</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;  </span><br><span class="line">    sem_wait(&amp;sem2);</span><br><span class="line">    print_string(arg);   </span><br><span class="line">    sem_post(&amp;sem1);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> *<span class="title function_">my_func2</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;     </span><br><span class="line">    sem_wait(&amp;sem1);   </span><br><span class="line">    print_string(arg); </span><br><span class="line">    sem_post(&amp;sem2); &#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;   </span><br><span class="line">    sem_init(&amp;sem1, <span class="number">0</span>, <span class="number">1</span>);   </span><br><span class="line">    sem_init(&amp;sem2, <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, my_func1, <span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, my_func2, <span class="string">&quot;hello china&quot;</span>); </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);  </span><br><span class="line">    sem_destroy(&amp;sem1); </span><br><span class="line">    sem_destroy(&amp;sem2);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>19.6无名信号量</strong></p>
<p><strong>1.无名信号量概述</strong></p>
<p>用于有血缘关系的进程进程间的同步与互斥，使用的是磁盘映射方式来实现的。</p>
<p>进程中初始化方式：</p>
<p>MAP_ANONYMOUS &#x2F;&#x2F;匿名映射</p>
<p>sem_t sem; &#x2F;&#x2F;线程中定义信号量的方式 &#x2F;&#x2F;进程为信号量分配地址空间的方式 sem_t *sem &#x3D; (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ|PROT_WRITE, MAP_SHARED|MAPANONYMOUS, -1, 0);</p>
<p>后续的sem_init、sem_wait、sem_post、sem_destroy都一样，链接的时候都需加上-lpthread.</p>
<p><strong>2.案例：有血缘关系进程的互斥</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);   </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);     </span><br><span class="line">        usleep(<span class="number">200</span> * <span class="number">1000</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 通过磁盘映射的方式创建一个信号量 </span></span><br><span class="line">    <span class="type">sem_t</span> *sem = (<span class="type">sem_t</span> *)mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sem_t</span>), PROT_READ | PROT_WRITE,                               MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line">    sem_init(sem, <span class="number">1</span>, <span class="number">1</span>);   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程 </span></span><br><span class="line">    &#123;        </span><br><span class="line">        sem_wait(sem);  </span><br><span class="line">        print_string(<span class="string">&quot;hello world&quot;</span>);   </span><br><span class="line">        sem_post(sem);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程  </span></span><br><span class="line">    &#123;       </span><br><span class="line">        sem_wait(sem);   </span><br><span class="line">        print_string(<span class="string">&quot;hello china&quot;</span>);  </span><br><span class="line">        sem_post(sem);    </span><br><span class="line">        wait(<span class="literal">NULL</span>);    &#125;    </span><br><span class="line">    <span class="comment">// 销毁信号量  </span></span><br><span class="line">    sem_destroy(sem);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.案例：有血缘关系进程的同步</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);     </span><br><span class="line">        usleep(<span class="number">200</span> * <span class="number">1000</span>);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 通过磁盘映射的方式创建一个信号量   </span></span><br><span class="line">    <span class="type">sem_t</span> *sem1 = (<span class="type">sem_t</span> *)mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sem_t</span>), PROT_READ | PROT_WRITE,                                MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line">    <span class="type">sem_t</span> *sem2 = (<span class="type">sem_t</span> *)mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sem_t</span>), PROT_READ | PROT_WRITE,                                MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line">    sem_init(sem1, <span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">    sem_init(sem2, <span class="number">1</span>, <span class="number">0</span>);   </span><br><span class="line">    <span class="type">pid_t</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程  </span></span><br><span class="line">    &#123;     </span><br><span class="line">        sem_wait(sem2); </span><br><span class="line">        print_string(<span class="string">&quot;hello world&quot;</span>);      </span><br><span class="line">        sem_post(sem1);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程  </span></span><br><span class="line">    &#123;       </span><br><span class="line">        sem_wait(sem1);</span><br><span class="line">        print_string(<span class="string">&quot;hello china&quot;</span>);  </span><br><span class="line">        sem_post(sem2);  </span><br><span class="line">        wait(<span class="literal">NULL</span>); </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">// 销毁信号量  </span></span><br><span class="line">    sem_destroy(sem1); </span><br><span class="line">    sem_destroy(sem2);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>19.7有名信号量</strong></p>
<p><strong>1.有名信号量的创建</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* For O_* constants */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>        <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> </span></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span>; <span class="comment">//信号量存在情况下 </span></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span>; <span class="comment">//信号量不存在情况下</span></span><br></pre></td></tr></table></figure></div>

<p>链接的时候也需加上-lpthread</p>
<p>参数：</p>
<p>name：信号量对应文件名</p>
<p>oflag:    同函数open的flag一致(O_RDONLY、O_WRONLY、O_RDWR)</p>
<p>mode:   磁盘权限，0666</p>
<p>value:   信号量的初始值</p>
<p>返回值：</p>
<p>成功：返回信号量的地址</p>
<p>失败：NULL，可通过errno来获得错误信息</p>
<p><strong>2.关闭信号量</strong></p>
<p>int sem_close(sem_t * sem);</p>
<p><strong>3.删除信号量的文件</strong></p>
<p>unlink(const char * name);</p>
<p>P、V操作一致</p>
<p><strong>4.有名信号量的互斥操作案例</strong></p>
<p>codeA.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);     </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);     </span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">1000</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 创建有名信号量  </span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;semaphore&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>, <span class="number">1</span>);  </span><br><span class="line">    sem_wait(sem);  </span><br><span class="line">    print_string(<span class="string">&quot;hello china&quot;</span>);   </span><br><span class="line">    sem_post(sem);  </span><br><span class="line">    <span class="comment">// 关闭信号量  </span></span><br><span class="line">    sem_close(sem);     </span><br><span class="line">    <span class="comment">// 销毁信号量    </span></span><br><span class="line">    sem_destroy(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>codeB.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">1000</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 创建有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;semaphore&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>, <span class="number">1</span>);  </span><br><span class="line">    sem_wait(sem); </span><br><span class="line">    print_string(<span class="string">&quot;hello world&quot;</span>);   </span><br><span class="line">    sem_post(sem); </span><br><span class="line">    <span class="comment">// 关闭信号量  </span></span><br><span class="line">    sem_close(sem);    </span><br><span class="line">    <span class="comment">// 销毁信号量  </span></span><br><span class="line">    sem_destroy(sem);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>5.有名信号量同步操作案例</strong></p>
<p>codeA.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>)  </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);    </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">1000</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">sem_t</span> *sem1 = sem_open(<span class="string">&quot;sem5&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);    </span><br><span class="line">    <span class="type">sem_t</span> *sem2 = sem_open(<span class="string">&quot;sem6&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    sem_wait(sem1);   </span><br><span class="line">    print_string(<span class="string">&quot;hello china&quot;</span>);</span><br><span class="line">    sem_post(sem2);    </span><br><span class="line">    sem_close(sem1);   </span><br><span class="line">    sem_close(sem2);  </span><br><span class="line">    unlink(<span class="string">&quot;sem5&quot;</span>);   </span><br><span class="line">    unlink(<span class="string">&quot;sem6&quot;</span>);  </span><br><span class="line">    sem_destroy(sem1);   </span><br><span class="line">    sem_destroy(sem2);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>codeB.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">void</span> *str)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)str;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (p[i] != <span class="string">&#x27;\0&#x27;</span>)   </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[i++]);   </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">1000</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">sem_t</span> *sem1 = sem_open(<span class="string">&quot;sem5&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="number">1</span>); </span><br><span class="line">    <span class="type">sem_t</span> *sem2 = sem_open(<span class="string">&quot;sem6&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);    </span><br><span class="line">    sem_wait(sem2); </span><br><span class="line">    print_string(<span class="string">&quot;hello world&quot;</span>);   </span><br><span class="line">    sem_post(sem1);   </span><br><span class="line">    sem_close(sem1);  </span><br><span class="line">    sem_close(sem2);  </span><br><span class="line">    unlink(<span class="string">&quot;sem5&quot;</span>);   </span><br><span class="line">    unlink(<span class="string">&quot;sem6&quot;</span>);   </span><br><span class="line">    sem_destroy(sem1);</span><br><span class="line">    sem_destroy(sem2);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> linux高级系统编程</li>
        <li><strong>作者:</strong> BAI ZHOU</li>
        <li><strong>创建于
                :</strong> 2024-01-07 16:56:21</li>
        
            <li>
                <strong>更新于
                    :</strong> 2024-01-07 21:32:31
            </li>
        
        <li>
            <strong>链接:</strong> https://redefine.ohevan.com/2024/01/07/linux高级系统编程/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/linux/">#linux</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/05/15/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">C语言函数</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2023/12/05/qt%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%AE%89%E8%A3%85/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">qt概述与安装</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">目录</div>
        <div class="page-title">linux高级系统编程</div>
        

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">月光是白昼寄给黑夜的情节，朝霞是黑夜思念白昼的泪光。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">BAI ZHOU</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 35 篇文章
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.1</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="站内搜索您需要的内容..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>








    
<script src="/js/libs/anime.min.js"></script>



<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
